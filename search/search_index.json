{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BGraph Overview BGraph (for Build-Graphs ) is a project aimed at create build graphs from blueprints in AOSP and querying those graphs. In short, this project builds/uses Unified Dependency Graph for the Android Open Source Project by parsing and linking modules defined in the Android build system Soong . Use-cases You should use this tool if you want to find: all the dependencies of a source file in AOSP; all the sources involved in the building of a target in AOSP; common dependencies between two targets. Usage (short) % bgraph --help Usage: bgraph [ OPTIONS ] COMMAND [ ARGS ] ... BGraph - generate and query build dependency graphes. BGraph is used to manipulate build dependency graphs generated from blueprint files. The main commands are: - generate : used to generates multiples graphs - query: used to query a previously generated graph To get more help, see the online documentation. Options: -v, --verbose Activate verbose output [ default: False ] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: generate Generate BGraph ' s from a mirror dir. generate-single Generate a BGraph from a branch. list List the BGraph already generated. query Query a BGraph. Installation pip install bgraph See Installation for more detailed information or other options. Citation This tool is the companion of the SSTIC Presentation If you want to cite it, you may use the following bibtex. @inproceedings{challande_exploitation_2021, location = {Rennes, France}, title = {Exploitation du graphe de d\u00e9pendance d'{AOSP} \u00e0 des fins de s\u00e9curit\u00e9}, url = {https://www.sstic.org/2021/presentation/bgraph/}, pages = {357--365}, booktitle = {Symposium sur la S\u00e9curit\u00e9 des Technologies de l'Information et des Communications 2021}, author = {Challande, Alexis and Renault, Gu\u00e9nael and David, Robin}, date = {2021-06}, langid = {french} }","title":"Overview"},{"location":"#bgraph","text":"","title":"BGraph"},{"location":"#overview","text":"BGraph (for Build-Graphs ) is a project aimed at create build graphs from blueprints in AOSP and querying those graphs. In short, this project builds/uses Unified Dependency Graph for the Android Open Source Project by parsing and linking modules defined in the Android build system Soong .","title":"Overview"},{"location":"#use-cases","text":"You should use this tool if you want to find: all the dependencies of a source file in AOSP; all the sources involved in the building of a target in AOSP; common dependencies between two targets.","title":"Use-cases"},{"location":"#usage-short","text":"% bgraph --help Usage: bgraph [ OPTIONS ] COMMAND [ ARGS ] ... BGraph - generate and query build dependency graphes. BGraph is used to manipulate build dependency graphs generated from blueprint files. The main commands are: - generate : used to generates multiples graphs - query: used to query a previously generated graph To get more help, see the online documentation. Options: -v, --verbose Activate verbose output [ default: False ] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: generate Generate BGraph ' s from a mirror dir. generate-single Generate a BGraph from a branch. list List the BGraph already generated. query Query a BGraph.","title":"Usage (short)"},{"location":"#installation","text":"pip install bgraph See Installation for more detailed information or other options.","title":"Installation"},{"location":"#citation","text":"This tool is the companion of the SSTIC Presentation If you want to cite it, you may use the following bibtex. @inproceedings{challande_exploitation_2021, location = {Rennes, France}, title = {Exploitation du graphe de d\u00e9pendance d'{AOSP} \u00e0 des fins de s\u00e9curit\u00e9}, url = {https://www.sstic.org/2021/presentation/bgraph/}, pages = {357--365}, booktitle = {Symposium sur la S\u00e9curit\u00e9 des Technologies de l'Information et des Communications 2021}, author = {Challande, Alexis and Renault, Gu\u00e9nael and David, Robin}, date = {2021-06}, langid = {french} }","title":"Citation"},{"location":"building/","text":"Generate the graph for a version of AOSP This small tutorial will help you to generate a BGraph for a specific version of AOSP. Note This will assume that you were able to install repo (and it is available in the $PATH ) and you have access to an AOSP mirror. BGraph: generate-single Info The generation process needs around ~1/2 Go at peak usage and finished with ~125 Mo. % bgraph generate-single --help Usage: bgraph generate-single [ OPTIONS ] RESULT_DIR BRANCH_NAME MIRROR Generate a BGraph from a branch. It will work in the workdir and store results in result_dir. Arguments: RESULT_DIR Where to store the result [ required ] BRANCH_NAME Branch from which generating the BGraph [ required ] MIRROR Mirror directory for AOSP ( either a link or a path ) [ required ] Options: --workdir PATH Workdir --help Show this message and exit. Example (using AOSP directory) Warning This process takes some time (~15 min) and if you have no local mirror, some network bandwidth. % bgraph generate-single --workdir /tmp/bgraph graphs/ android-10.0.0_r1 'https://android.googlesource.com' This command creates the BGraph of android-10.0.0_r1 and store it in graphs/ . It will use the /tmp/bgraph directory to work (must exists first) and will perform a checkout from Google AOSP root tree. Note graphs/ is the output directory in the following examples and must be writable. Example (using a local mirror) If you have an AOSP local mirror mounted in /mnt/mirror/mirror and wants to generate the graph for android-11.0.0_r1 . % mkdir graphs # where to store the results % bgraph generate-single graphs/ android-11.0.0_r1 /mnt/mirror/mirror/ At the end, if everything went well, you will find % ls graphs/ android-11.0.0_r1.bgraph This object is a pickle file representing a networkx.DiGraph . Options workdir : If the option is specified, all the work will be done in the workdir. Otherwise, this will create a new directory in /tmp . This is useful if you want to generate multiple BGraphs and want to do them only once (or restart.) Listing branch In the example, we asked for generating the BGraph of branch android-11.0.0_r1 but there exists numerous of them in AOSP tree. You may find the list of branches on Google website Or using this command (if you have a local mirror): % cd /mnt/mirror/platform/manifest.git % git branch -a BGraph: generate If you want to generate BGraph for multiples branches in AOSP, you can use the generate command. This takes an additional argument --branch-pattern which defaults to android-* and will restrict the branches built. % bgraph generate --help Usage: bgraph generate [ OPTIONS ] RESULT_DIR MIRROR Generate BGraph ' s from a mirror dir. Arguments: RESULT_DIR Where to store the resulting BGraph [ required ] MIRROR Path to the mirror or the URL to AOSP source [ required ] Options: --branch-pattern TEXT Pattern to match the branches [ default: android-* ] --workdir PATH Work directory ( default will be a tmp directory ) --help Show this message and exit. Troubleshooting Many failed to fetch errors Google rate limits the requests for anonymous user but BGraph tries to be as fast as possible by running checkouts on multiple cores. A solution to this is to use authentication to Google server, following their guide here . Finally, assuming you are building inside the container, the command would look like this : % docker run --rm \\ # Where to store the graphs -v $( pwd ) /graphs:/home/user/graphs \\ # Git config file -v $( HOME ) /.gitconfig:/home/user/.gitconfig \\ # Git cookies files -v $( HOME ) /.gitcookies:/home/user/.git/cookies \\ # Container name and command bgraph:latest bgraph generate-single graphs/ 'android-10.0.0_r1' \\ # Use the authenticated mirror 'https://android.googlesource.com/a' See Docker for more informations on how to build inside the container.","title":"Building"},{"location":"building/#generate-the-graph-for-a-version-of-aosp","text":"This small tutorial will help you to generate a BGraph for a specific version of AOSP. Note This will assume that you were able to install repo (and it is available in the $PATH ) and you have access to an AOSP mirror.","title":"Generate the graph for a version of AOSP"},{"location":"building/#bgraph-generate-single","text":"Info The generation process needs around ~1/2 Go at peak usage and finished with ~125 Mo. % bgraph generate-single --help Usage: bgraph generate-single [ OPTIONS ] RESULT_DIR BRANCH_NAME MIRROR Generate a BGraph from a branch. It will work in the workdir and store results in result_dir. Arguments: RESULT_DIR Where to store the result [ required ] BRANCH_NAME Branch from which generating the BGraph [ required ] MIRROR Mirror directory for AOSP ( either a link or a path ) [ required ] Options: --workdir PATH Workdir --help Show this message and exit.","title":"BGraph: generate-single"},{"location":"building/#example-using-aosp-directory","text":"Warning This process takes some time (~15 min) and if you have no local mirror, some network bandwidth. % bgraph generate-single --workdir /tmp/bgraph graphs/ android-10.0.0_r1 'https://android.googlesource.com' This command creates the BGraph of android-10.0.0_r1 and store it in graphs/ . It will use the /tmp/bgraph directory to work (must exists first) and will perform a checkout from Google AOSP root tree. Note graphs/ is the output directory in the following examples and must be writable.","title":"Example (using AOSP directory)"},{"location":"building/#example-using-a-local-mirror","text":"If you have an AOSP local mirror mounted in /mnt/mirror/mirror and wants to generate the graph for android-11.0.0_r1 . % mkdir graphs # where to store the results % bgraph generate-single graphs/ android-11.0.0_r1 /mnt/mirror/mirror/ At the end, if everything went well, you will find % ls graphs/ android-11.0.0_r1.bgraph This object is a pickle file representing a networkx.DiGraph .","title":"Example (using a local mirror)"},{"location":"building/#options","text":"workdir : If the option is specified, all the work will be done in the workdir. Otherwise, this will create a new directory in /tmp . This is useful if you want to generate multiple BGraphs and want to do them only once (or restart.)","title":"Options"},{"location":"building/#listing-branch","text":"In the example, we asked for generating the BGraph of branch android-11.0.0_r1 but there exists numerous of them in AOSP tree. You may find the list of branches on Google website Or using this command (if you have a local mirror): % cd /mnt/mirror/platform/manifest.git % git branch -a","title":"Listing branch"},{"location":"building/#bgraph-generate","text":"If you want to generate BGraph for multiples branches in AOSP, you can use the generate command. This takes an additional argument --branch-pattern which defaults to android-* and will restrict the branches built. % bgraph generate --help Usage: bgraph generate [ OPTIONS ] RESULT_DIR MIRROR Generate BGraph ' s from a mirror dir. Arguments: RESULT_DIR Where to store the resulting BGraph [ required ] MIRROR Path to the mirror or the URL to AOSP source [ required ] Options: --branch-pattern TEXT Pattern to match the branches [ default: android-* ] --workdir PATH Work directory ( default will be a tmp directory ) --help Show this message and exit.","title":"BGraph: generate"},{"location":"building/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"building/#many-failed-to-fetch-errors","text":"Google rate limits the requests for anonymous user but BGraph tries to be as fast as possible by running checkouts on multiple cores. A solution to this is to use authentication to Google server, following their guide here . Finally, assuming you are building inside the container, the command would look like this : % docker run --rm \\ # Where to store the graphs -v $( pwd ) /graphs:/home/user/graphs \\ # Git config file -v $( HOME ) /.gitconfig:/home/user/.gitconfig \\ # Git cookies files -v $( HOME ) /.gitcookies:/home/user/.git/cookies \\ # Container name and command bgraph:latest bgraph generate-single graphs/ 'android-10.0.0_r1' \\ # Use the authenticated mirror 'https://android.googlesource.com/a' See Docker for more informations on how to build inside the container.","title":"Many failed to fetch errors"},{"location":"contribute/","text":"Contributing Welcome! First, many thanks if you are willing to contribute to this project. Everyone is welcome. Bird's eye view BGraph and its inner-workings are explained in the Innerworkings part of the documentation. Code organization The code is mainly split in three parts. Builder The builder is responsible for the logic around fetching build compilation directives. Today it is tightly coupled with AOSP. The graph part of the builder convert a soong file into an Unified Depency Graph. Parsers It is the place where the build compilation directives files are analyzed. Today, only blueprints (Soong configuration files) are analyzed. But if you want to add the support for another kind of file, it is the place to go. Note Start a Pull Request/Issue before starting to work on it as it requires some refactoring in the code. Viewer Everything that deals with the querying and outputting results on bgraphs is stored there. For developers Testing There aren't many tests written for the project yet , and even most of the Soong Parser isn't properly tested. However, the few tests that are present are runned using the following snippet. $ poetry install # To install with dev-dependencies $ poetry run pytest --cov = bgraph # To run the tests Contributions are encouraged to add tests. Linting The code follow a strict black formatting. To run the linter: $ poetry run black src tests Type check The code normally pass mypy checks without problems. $ poetry run mypy src/","title":"Contribution"},{"location":"contribute/#contributing","text":"Welcome! First, many thanks if you are willing to contribute to this project. Everyone is welcome.","title":"Contributing"},{"location":"contribute/#birds-eye-view","text":"BGraph and its inner-workings are explained in the Innerworkings part of the documentation.","title":"Bird's eye view"},{"location":"contribute/#code-organization","text":"The code is mainly split in three parts.","title":"Code organization"},{"location":"contribute/#builder","text":"The builder is responsible for the logic around fetching build compilation directives. Today it is tightly coupled with AOSP. The graph part of the builder convert a soong file into an Unified Depency Graph.","title":"Builder"},{"location":"contribute/#parsers","text":"It is the place where the build compilation directives files are analyzed. Today, only blueprints (Soong configuration files) are analyzed. But if you want to add the support for another kind of file, it is the place to go. Note Start a Pull Request/Issue before starting to work on it as it requires some refactoring in the code.","title":"Parsers"},{"location":"contribute/#viewer","text":"Everything that deals with the querying and outputting results on bgraphs is stored there.","title":"Viewer"},{"location":"contribute/#for-developers","text":"","title":"For developers"},{"location":"contribute/#testing","text":"There aren't many tests written for the project yet , and even most of the Soong Parser isn't properly tested. However, the few tests that are present are runned using the following snippet. $ poetry install # To install with dev-dependencies $ poetry run pytest --cov = bgraph # To run the tests Contributions are encouraged to add tests.","title":"Testing"},{"location":"contribute/#linting","text":"The code follow a strict black formatting. To run the linter: $ poetry run black src tests","title":"Linting"},{"location":"contribute/#type-check","text":"The code normally pass mypy checks without problems. $ poetry run mypy src/","title":"Type check"},{"location":"docker/","text":"Docker usage (experimental) A Dockerfile is available in docker/ directory. It has not been properly tested but should still work. Content The container will have all the dependencies required to build BGraphs including : - git v2.29 - repo - BGraph itself Building $ docker build -f docker/Dockerfile -t bgraph . This step will take some times because it will download and compile a few components (like git). Note By default, the container will stop at the last image. You may add the --target parameter to stop at earlier stages. Usage $ docker run bgraph Building BGraph inside Docker (untested) Note The builder inside the container needs a valid gitconfig file. An option is to copy the one used in the system (usually in $HOME/.git/config ). $ docker run \\ --rm \\ -v $( pwd ) /graphs:/home/user/graphs \\ # To retrieve the generated graph -v $XDG_CONFIG_DIR /git/config:/home/user/.gitconfig \\ # User/Email should be defined bgraph:latest \\ # Image name bgraph generate-single graphs/ android-10.0.0_r2 'https://android.googlesource.com'","title":"Docker"},{"location":"docker/#docker-usage-experimental","text":"A Dockerfile is available in docker/ directory. It has not been properly tested but should still work.","title":"Docker usage (experimental)"},{"location":"docker/#content","text":"The container will have all the dependencies required to build BGraphs including : - git v2.29 - repo - BGraph itself","title":"Content"},{"location":"docker/#building","text":"$ docker build -f docker/Dockerfile -t bgraph . This step will take some times because it will download and compile a few components (like git). Note By default, the container will stop at the last image. You may add the --target parameter to stop at earlier stages.","title":"Building"},{"location":"docker/#usage","text":"$ docker run bgraph","title":"Usage"},{"location":"docker/#building-bgraph-inside-docker-untested","text":"Note The builder inside the container needs a valid gitconfig file. An option is to copy the one used in the system (usually in $HOME/.git/config ). $ docker run \\ --rm \\ -v $( pwd ) /graphs:/home/user/graphs \\ # To retrieve the generated graph -v $XDG_CONFIG_DIR /git/config:/home/user/.gitconfig \\ # User/Email should be defined bgraph:latest \\ # Image name bgraph generate-single graphs/ android-10.0.0_r2 'https://android.googlesource.com'","title":"Building BGraph inside Docker (untested)"},{"location":"explanations/","text":"Inner workings Methodology This work creates a Unified Dependency Graph (UDG) for every module found in a root tree of AOSP. The UDG in BGraph is a graph where the nodes are either sources files or valid Soong targets. Every node in the graph is linked to all its dependent (either because they use them or because they need them). Algorithm The algorithm is roughly described below: Discover every Android.bp Parses them as \"targets\" and store the result Get the list of files in each of the projects and store it Combine every module: Resolve wildcards in blueprint definitions with the list of files of the project Create link for dependency keys in blueprints Save the bgraph . To go further See the paper or the presentation at SSTIC 2021.","title":"Innerworkings"},{"location":"explanations/#inner-workings","text":"","title":"Inner workings"},{"location":"explanations/#methodology","text":"This work creates a Unified Dependency Graph (UDG) for every module found in a root tree of AOSP. The UDG in BGraph is a graph where the nodes are either sources files or valid Soong targets. Every node in the graph is linked to all its dependent (either because they use them or because they need them).","title":"Methodology"},{"location":"explanations/#algorithm","text":"The algorithm is roughly described below: Discover every Android.bp Parses them as \"targets\" and store the result Get the list of files in each of the projects and store it Combine every module: Resolve wildcards in blueprint definitions with the list of files of the project Create link for dependency keys in blueprints Save the bgraph .","title":"Algorithm"},{"location":"explanations/#to-go-further","text":"See the paper or the presentation at SSTIC 2021.","title":"To go further"},{"location":"installation/","text":"Pre-requistes BGraph is divided in two components: the builder and the viewer. Viewer dependencies: python3.8 Builder dependencies git (v22+): since partial checkouts are used, a modern version of git is needed. The project has been tested with Git 2.29. repo : Google project to query AOSP repository . See the installation instruction from Google. A repo client . Optional: An AOSP mirror to have a faster building time. The mirror is not necessary, but it reduces the number of requests to Google servers. Tip An alternative way to install repo is to use the one packaged for your distribution, but it is not recommended. Installation Tip Install BGraph in a virtualenv. With pip pip install bgraph With poetry Note Poetry is a python packaging and dependency manager $ git clone git@github.com:quarkslab/bgraph.git $ cd bgraph $ poetry install --no-dev Checks (for building) $ mkdir android-current && cd android-current $ repo init -u https://android.googlesource.com/platform/manifest -c --depth = 1 --partial-clone --clone-filter = blob:none If this commands succeeded, you are good to go!","title":"Installation"},{"location":"installation/#pre-requistes","text":"BGraph is divided in two components: the builder and the viewer.","title":"Pre-requistes"},{"location":"installation/#viewer-dependencies","text":"python3.8","title":"Viewer dependencies:"},{"location":"installation/#builder-dependencies","text":"git (v22+): since partial checkouts are used, a modern version of git is needed. The project has been tested with Git 2.29. repo : Google project to query AOSP repository . See the installation instruction from Google. A repo client . Optional: An AOSP mirror to have a faster building time. The mirror is not necessary, but it reduces the number of requests to Google servers. Tip An alternative way to install repo is to use the one packaged for your distribution, but it is not recommended.","title":"Builder dependencies"},{"location":"installation/#installation","text":"Tip Install BGraph in a virtualenv.","title":"Installation"},{"location":"installation/#with-pip","text":"pip install bgraph","title":"With pip"},{"location":"installation/#with-poetry","text":"Note Poetry is a python packaging and dependency manager $ git clone git@github.com:quarkslab/bgraph.git $ cd bgraph $ poetry install --no-dev","title":"With poetry"},{"location":"installation/#checks-for-building","text":"$ mkdir android-current && cd android-current $ repo init -u https://android.googlesource.com/platform/manifest -c --depth = 1 --partial-clone --clone-filter = blob:none If this commands succeeded, you are good to go!","title":"Checks (for building)"},{"location":"limitations/","text":"Limitations and frequent errors Soong parsing is not complete The parsing of blueprints files is not complete, and some features are not supported (like soong_namespaces.) Dependency is wrong/missing/incomplete There are some cases when the dependency is bogus: it uses an unsupported feature of Soong (please open an issue to let us know) the module is still uses Android.mk files: nothing to do (or implement a Android.mk parser) there is a bug in BGraph : please open an issue with enough details so we can reproduce it","title":"Limitations"},{"location":"limitations/#limitations-and-frequent-errors","text":"","title":"Limitations and frequent errors"},{"location":"limitations/#soong-parsing-is-not-complete","text":"The parsing of blueprints files is not complete, and some features are not supported (like soong_namespaces.)","title":"Soong parsing is not complete"},{"location":"limitations/#dependency-is-wrongmissingincomplete","text":"There are some cases when the dependency is bogus: it uses an unsupported feature of Soong (please open an issue to let us know) the module is still uses Android.mk files: nothing to do (or implement a Android.mk parser) there is a bug in BGraph : please open an issue with enough details so we can reproduce it","title":"Dependency is wrong/missing/incomplete"},{"location":"query/","text":"Example This example assumes you have already created the BGraph for android-10.0.0_r1 and the file is available in graphs/android-10.0.0_r1.bgraph . First query: dependencies of a source file The patch for the CVE-2020-0471 modifies the file packet_fragmenter.cc ( commit: ca6b0a ). We are interested in the different targets (e.g. binaries and libraries) where we can find the content of this file in AOSP. % bgraph query graphs/android-10.0.0_r1.bgraph --src 'packet_fragmenter.cc' Dependencies for source file packet_fragmenter.cc \u2577 \u2577 Target \u2502 Type \u2502 Distance \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 libbt-hci \u2502 cc_library_static \u2502 1 libbt-stack \u2502 cc_library_static \u2502 2 libbluetooth \u2502 cc_library_shared \u2502 2 \u2575 \u2575 Warning The example assumes you have already created the bgraph for android-10.0.0_r1 . Second query: let's find sources of library % bgraph query graphs/android-10.0.0_r1.bgraph --target libbluetooth-types-header Sources for the target libbluetooth-types-header \u2577 Filename \u2502 File type \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/class_of_device.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/bluetooth/uuid_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/bluetooth/uuid.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/raw_address.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/BUILD.gn \u2502 .gn /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/raw_address_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/Android.bp \u2502 .bp /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/bluetooth/uuid.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/class_of_device_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/raw_address.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/class_of_device.cc \u2502 .cc \u2575 Note This type of requests can leads to huge number of results and are not really suited for a command line usage. For example, the result for the target query of libbluetooth yields to more than 5700 lines of results. Use as a library BGraph is also a library and can be used like one. Note All the examples can be runned as-if assuming you are at the root directory of the project and a bgraph for android-10.0.0_r1 is found in graphs/ . Example import bgraph # Load the graph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) # Query to find the source dependencies of libbluetooth sources = bgraph . viewer . find_sources ( graph , \"libbluetooth\" ) for source in filter ( lambda x : 'zlib' in x , sources ): print ( f \"Zlib file: { source } \" ) Format results import bgraph from bgraph.types import QueryType , OutChoice # Load the graph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) sources = bgraph . viewer . find_sources ( graph , \"libbluetooth\" ) bgraph . viewer . format_result ( graph , sources , query = QueryType . TARGET , query_value = \"libbluetooth\" , out_choice = OutChoice . DOT ) Iterative process In this example, we are looking for the first target using Parcel.cpp . This will illustrate both the radius argument of the find_target method and what to do when multiple files matches the name we are looking for. import bgraph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) # Will raise an exception : TooManyNodes - refine the search bgraph . viewer . find_target ( graph , \"Parcel.cpp\" , radius = 1 ) # Indeed, there are many sources files having \"Parcel.cpp\" in their name graph_srcs = [ node for node in graph if bgraph . viewer . get_node_type ( node ) == \"source\" ] potential_results = [ node for node in graph_srcs if \"Parcel.cpp\" in node ] print ( f \"Found { len ( potential_results ) } / { len ( graph_srcs ) } matching nodes\" ) # In this case, it is possible to use a more precise path: file , target = bgraph . viewer . find_target ( graph , \"libs/binder/Parcel.cpp\" , radius = 1 ) print ( f \" { file } is used in { target } \" ) # file in this case will be the absolute path to the Parcel.cpp found.","title":"Querying"},{"location":"query/#example","text":"This example assumes you have already created the BGraph for android-10.0.0_r1 and the file is available in graphs/android-10.0.0_r1.bgraph .","title":"Example"},{"location":"query/#first-query-dependencies-of-a-source-file","text":"The patch for the CVE-2020-0471 modifies the file packet_fragmenter.cc ( commit: ca6b0a ). We are interested in the different targets (e.g. binaries and libraries) where we can find the content of this file in AOSP. % bgraph query graphs/android-10.0.0_r1.bgraph --src 'packet_fragmenter.cc' Dependencies for source file packet_fragmenter.cc \u2577 \u2577 Target \u2502 Type \u2502 Distance \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 libbt-hci \u2502 cc_library_static \u2502 1 libbt-stack \u2502 cc_library_static \u2502 2 libbluetooth \u2502 cc_library_shared \u2502 2 \u2575 \u2575 Warning The example assumes you have already created the bgraph for android-10.0.0_r1 .","title":"First query: dependencies of a source file"},{"location":"query/#second-query-lets-find-sources-of-library","text":"% bgraph query graphs/android-10.0.0_r1.bgraph --target libbluetooth-types-header Sources for the target libbluetooth-types-header \u2577 Filename \u2502 File type \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/class_of_device.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/bluetooth/uuid_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/bluetooth/uuid.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/raw_address.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/BUILD.gn \u2502 .gn /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/raw_address_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/Android.bp \u2502 .bp /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/bluetooth/uuid.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/test/class_of_device_unittest.cc \u2502 .cc /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/raw_address.h \u2502 .h /tmp/bgraph_6p4534y2/android-10.0.0_r1/system/bt/types/class_of_device.cc \u2502 .cc \u2575 Note This type of requests can leads to huge number of results and are not really suited for a command line usage. For example, the result for the target query of libbluetooth yields to more than 5700 lines of results.","title":"Second query: let's find sources of library"},{"location":"query/#use-as-a-library","text":"BGraph is also a library and can be used like one. Note All the examples can be runned as-if assuming you are at the root directory of the project and a bgraph for android-10.0.0_r1 is found in graphs/ .","title":"Use as a library"},{"location":"query/#example_1","text":"import bgraph # Load the graph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) # Query to find the source dependencies of libbluetooth sources = bgraph . viewer . find_sources ( graph , \"libbluetooth\" ) for source in filter ( lambda x : 'zlib' in x , sources ): print ( f \"Zlib file: { source } \" )","title":"Example"},{"location":"query/#format-results","text":"import bgraph from bgraph.types import QueryType , OutChoice # Load the graph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) sources = bgraph . viewer . find_sources ( graph , \"libbluetooth\" ) bgraph . viewer . format_result ( graph , sources , query = QueryType . TARGET , query_value = \"libbluetooth\" , out_choice = OutChoice . DOT )","title":"Format results"},{"location":"query/#iterative-process","text":"In this example, we are looking for the first target using Parcel.cpp . This will illustrate both the radius argument of the find_target method and what to do when multiple files matches the name we are looking for. import bgraph graph = bgraph . viewer . load_graph ( \"graphs/android-10.0.0_r1.bgraph\" ) # Will raise an exception : TooManyNodes - refine the search bgraph . viewer . find_target ( graph , \"Parcel.cpp\" , radius = 1 ) # Indeed, there are many sources files having \"Parcel.cpp\" in their name graph_srcs = [ node for node in graph if bgraph . viewer . get_node_type ( node ) == \"source\" ] potential_results = [ node for node in graph_srcs if \"Parcel.cpp\" in node ] print ( f \"Found { len ( potential_results ) } / { len ( graph_srcs ) } matching nodes\" ) # In this case, it is possible to use a more precise path: file , target = bgraph . viewer . find_target ( graph , \"libs/binder/Parcel.cpp\" , radius = 1 ) print ( f \" { file } is used in { target } \" ) # file in this case will be the absolute path to the Parcel.cpp found.","title":"Iterative process"},{"location":"roadmap/","text":"Roadmap / improvements ideas Note This list of features / improvements is more a wishlist than anything else. Do not expect them to be implemented soon or ever. Meta Change BGraph format from pickle to protobuf Code refactoring for decoupling soong parser Improve documentation Parsers Soong Parser Namespaces support Filegroup support Automatic types discovery Better handling of dependencies link (and support for exclude_ ) Android.mk Add an Android.mk parser (or use androidmk to convert Android.mk) UX Improve options for text formatting (sorting, filtering)","title":"Roadmap"},{"location":"roadmap/#roadmap-improvements-ideas","text":"Note This list of features / improvements is more a wishlist than anything else. Do not expect them to be implemented soon or ever.","title":"Roadmap / improvements ideas"},{"location":"roadmap/#meta","text":"Change BGraph format from pickle to protobuf Code refactoring for decoupling soong parser Improve documentation","title":"Meta"},{"location":"roadmap/#parsers","text":"","title":"Parsers"},{"location":"roadmap/#soong-parser","text":"Namespaces support Filegroup support Automatic types discovery Better handling of dependencies link (and support for exclude_ )","title":"Soong Parser"},{"location":"roadmap/#androidmk","text":"Add an Android.mk parser (or use androidmk to convert Android.mk)","title":"Android.mk"},{"location":"roadmap/#ux","text":"Improve options for text formatting (sorting, filtering)","title":"UX"},{"location":"reference/utils/","text":"clean_mirror_path ( mirror ) Convert the user input from command line to an acceptable format for the app. Note: If the user provided an URL, it will remove any trailing '/'. Parameters: Name Type Description Default mirror str User input required Returns: Type Description Union[str, pathlib.Path] Either a Path object or a string Source code in bgraph/utils.py def clean_mirror_path ( mirror : str ) -> Union [ str , pathlib . Path ]: \"\"\"Convert the user input from command line to an acceptable format for the app. Note: If the user provided an URL, it will remove any trailing '/'. :param mirror: User input :return: Either a Path object or a string \"\"\" # First, detect if the string is an url mirror_path : Union [ str , pathlib . Path ] = ( pathlib . Path ( mirror ) if \"http\" not in mirror else mirror ) # Remove trailing '/' if needed if isinstance ( mirror_path , str ) and mirror_path . endswith ( \"/\" ): mirror_path = mirror_path [: - 1 ] return mirror_path create_logger ( logger_name ) Set up logging using the logger_name Source code in bgraph/utils.py def create_logger ( logger_name : str ) -> logging . Logger : \"\"\"Set up logging using the `logger_name`\"\"\" logger = logging . getLogger ( logger_name ) # Create console handler if not already present if not logger . handlers : ch = logging . StreamHandler () formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) ch . setFormatter ( formatter ) logger . addHandler ( ch ) return logger no_except ( f ) Prevent failures when running f. Source code in bgraph/utils.py def no_except ( f : Callable ) -> Callable : \"\"\"Prevent failures when running f.\"\"\" logger : logging . Logger = create_logger ( __name__ ) @functools . wraps ( f ) def wrapper ( * args , ** kwargs ): try : return f ( * args , ** kwargs ) except Exception as e : logger . exception ( e ) return wrapper recurse ( mapping ) Recurse through a mapping and yield every key value pairs. Parameters: Name Type Description Default mapping Dict[Any, Any] A mapping to unroll required Source code in bgraph/utils.py def recurse ( mapping : Dict [ Any , Any ]) -> Generator [ Tuple [ Any , Any ], None , None ]: \"\"\"Recurse through a mapping and yield every key value pairs. :param mapping: A mapping to unroll \"\"\" for key , value in mapping . items (): if type ( value ) is dict : yield from recurse ( value ) else : yield key , value","title":"utils"},{"location":"reference/utils/#bgraph.utils.clean_mirror_path","text":"Convert the user input from command line to an acceptable format for the app. Note: If the user provided an URL, it will remove any trailing '/'. Parameters: Name Type Description Default mirror str User input required Returns: Type Description Union[str, pathlib.Path] Either a Path object or a string Source code in bgraph/utils.py def clean_mirror_path ( mirror : str ) -> Union [ str , pathlib . Path ]: \"\"\"Convert the user input from command line to an acceptable format for the app. Note: If the user provided an URL, it will remove any trailing '/'. :param mirror: User input :return: Either a Path object or a string \"\"\" # First, detect if the string is an url mirror_path : Union [ str , pathlib . Path ] = ( pathlib . Path ( mirror ) if \"http\" not in mirror else mirror ) # Remove trailing '/' if needed if isinstance ( mirror_path , str ) and mirror_path . endswith ( \"/\" ): mirror_path = mirror_path [: - 1 ] return mirror_path","title":"clean_mirror_path()"},{"location":"reference/utils/#bgraph.utils.create_logger","text":"Set up logging using the logger_name Source code in bgraph/utils.py def create_logger ( logger_name : str ) -> logging . Logger : \"\"\"Set up logging using the `logger_name`\"\"\" logger = logging . getLogger ( logger_name ) # Create console handler if not already present if not logger . handlers : ch = logging . StreamHandler () formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) ch . setFormatter ( formatter ) logger . addHandler ( ch ) return logger","title":"create_logger()"},{"location":"reference/utils/#bgraph.utils.no_except","text":"Prevent failures when running f. Source code in bgraph/utils.py def no_except ( f : Callable ) -> Callable : \"\"\"Prevent failures when running f.\"\"\" logger : logging . Logger = create_logger ( __name__ ) @functools . wraps ( f ) def wrapper ( * args , ** kwargs ): try : return f ( * args , ** kwargs ) except Exception as e : logger . exception ( e ) return wrapper","title":"no_except()"},{"location":"reference/utils/#bgraph.utils.recurse","text":"Recurse through a mapping and yield every key value pairs. Parameters: Name Type Description Default mapping Dict[Any, Any] A mapping to unroll required Source code in bgraph/utils.py def recurse ( mapping : Dict [ Any , Any ]) -> Generator [ Tuple [ Any , Any ], None , None ]: \"\"\"Recurse through a mapping and yield every key value pairs. :param mapping: A mapping to unroll \"\"\" for key , value in mapping . items (): if type ( value ) is dict : yield from recurse ( value ) else : yield key , value","title":"recurse()"},{"location":"reference/builder/builder/","text":"builder Author: dm (achallande@quarkslab.com) Create source maps for AOSP. Prerequistes: - a recent git version (>2.20) - an AOSP mirror - time clean_disk ( branch_workdir ) Remove a branch directory on the disk to save some space Parameters: Name Type Description Default branch_workdir Path Path to the directory to remove required Source code in bgraph/builder/builder.py def clean_disk ( branch_workdir : Path ) -> None : \"\"\"Remove a branch directory on the disk to save some space :param branch_workdir: Path to the directory to remove \"\"\" if branch_workdir . is_dir (): shutil . rmtree ( branch_workdir , ignore_errors = True ) combine_files_path ( branch_dir ) Load the \"files.pickle\" stored with results of git commands. Parameters: Name Type Description Default branch_dir Path Directory to find the AOSP partial tree required Returns: Type Description Dict[pathlib.Path, List[str]] A mapping of path and the list of files inside the project Source code in bgraph/builder/builder.py def combine_files_path ( branch_dir : Path ) -> Dict [ Path , List [ str ]]: \"\"\"Load the \"files.pickle\" stored with results of git commands. :param branch_dir: Directory to find the AOSP partial tree :return: A mapping of path and the list of files inside the project \"\"\" files : Dict [ Path , List [ str ]] = {} for file_path in branch_dir . rglob ( \"files.pickle\" ): try : local_files = pickle . load ( open ( file_path , \"rb\" )) except pickle . PickleError : continue files [ file_path . parent ] = local_files return files compose_all ( mirror , branch_pattern = 'android-*' , work_dir = None , force = False ) Iterates through all the branches in AOSP and create the source maps. This methods: - list all the existing branches and filter those matching the pattern - does a partial checkout of each of them - parses the Soong File and store them Parameters: Name Type Description Default mirror Union[str, pathlib.Path] Path/Link to a mirror directory or an URL. required branch_pattern str Optional. Pattern to filter branches 'android-*' work_dir Optional[pathlib.Path] Optional. Work directory None force bool Optional. Overrides results. False Returns: Type Description Path The path to the work directory Source code in bgraph/builder/builder.py def compose_all ( mirror : Union [ str , Path ], branch_pattern : str = \"android-*\" , work_dir : Optional [ Path ] = None , force : bool = False , ) -> Path : \"\"\"Iterates through all the branches in AOSP and create the source maps. This methods: - list all the existing branches and filter those matching the pattern - does a partial checkout of each of them - parses the Soong File and store them :param mirror: Path/Link to a mirror directory or an URL. :param branch_pattern: Optional. Pattern to filter branches :param work_dir: Optional. Work directory :param force: Optional. Overrides results. :return: The path to the work directory \"\"\" # List branches all_branches = get_all_branches ( mirror ) branches = fnmatch . filter ( all_branches , branch_pattern ) if work_dir is None : work_dir = Path ( tempfile . mkdtemp ( prefix = \"bgraph_\" )) logger . info ( \"Found %d branches\" , len ( branches )) for branch_name in branches : compose_manifest_branch ( branch_name , mirror , work_dir , force ) logger . info ( \"Finished\" ) return work_dir compose_manifest_branch ( branch_name , mirror , work_dir = None , force = False ) Create the soong parser for a manifest branch. As the process is slow, multiprocessing.Pool is used to speed the checkout. The bottleneck is the parsing of blueprints files. However, since variables definition must be analyzed, we cannot just randomly parallelize this step and it must be done carefuly (read: it's not done yet.). The SoongParser is used to parse the whole tree blueprints files and stored using pickle. Another step is to convert this object as a (networkx) graph. Parameters: Name Type Description Default branch_name str Name of the branch to checkout required mirror Union[str, pathlib.Path] Path/Link towards the mirror or the manifest URL required work_dir Optional[pathlib.Path] Optional. Working directory - if not set, a temporary folder is used None force bool Optional. Overwrite existing branch. False Returns: Type Description Optional[pathlib.Path] The path to the work dir Source code in bgraph/builder/builder.py @bgraph . utils . no_except def compose_manifest_branch ( branch_name : str , mirror : Union [ str , Path ], work_dir : Optional [ Path ] = None , force : bool = False , ) -> Optional [ Path ]: \"\"\"Create the soong parser for a manifest branch. As the process is slow, multiprocessing.Pool is used to speed the checkout. The bottleneck is the parsing of blueprints files. However, since variables definition must be analyzed, we cannot just randomly parallelize this step and it must be done carefuly (read: it's not done yet.). The SoongParser is used to parse the whole tree blueprints files and stored using pickle. Another step is to convert this object as a (networkx) graph. :param branch_name: Name of the branch to checkout :param mirror: Path/Link towards the mirror or the manifest URL :param work_dir: Optional. Working directory - if not set, a temporary folder is used :param force: Optional. Overwrite existing branch. :return: The path to the work dir \"\"\" logger . info ( \"Start composing for %s \" , branch_name ) if work_dir is None : work_dir = Path ( tempfile . mkdtemp ( prefix = \"bgraph_\" )) # Guard: do not redo a branch pickle_file = work_dir / f \" { branch_name } .pickle\" if pickle_file . is_file () and force is False : logger . info ( \"Branch already found; skip.\" ) return work_dir elif ( work_dir / f \" { branch_name } .empty\" ) . is_file (): logger . info ( \"Branch empty; skip.\" ) return work_dir # Create a branch by using repo try : branch_dir = create_manifest_branch ( work_dir , mirror , branch_name ) except bgraph . exc . BGraphBuilderException : return None manifest_file = branch_dir / \".repo\" / \"manifests\" / \"default.xml\" logger . info ( \"List projects\" ) project_checkout_branch = functools . partial ( project_checkout , branch_name , branch_dir , mirror ) # Load the manifest manifest = bgraph . parsers . Manifest . from_file ( manifest_file ) # Core: multiprocessing with multiprocessing . Pool () as pool : res = pool . map_async ( project_checkout_branch , manifest . get_projects () . items ()) res . get ( 24 * 60 * 60 ) logger . info ( \"Finished to compose with %s \" , branch_name ) # Guard: Search build files for _ in branch_dir . rglob ( \"Android.bp\" ): break else : logger . info ( \"Found 0 Android.bp file, aborting\" ) # Create an empty file to prevent from doing it if we restart with open ( work_dir / f \" { branch_name } .empty\" , \"w\" ) as _ : pass clean_disk ( branch_dir ) return work_dir soong_parser = bgraph . parsers . SoongParser () logger . info ( \"Starting parsing AOSP build files\" ) soong_parser . parse_aosp ( branch_dir , project_map = manifest . get_projects ()) soong_parser . file_listing = combine_files_path ( branch_dir ) # Save the result try : pickle . dump ( soong_parser , open ( pickle_file , \"wb\" )) except pickle . PickleError : logger . error ( \"Failed to pickle\" ) clean_disk ( branch_dir ) return work_dir # Clean the disk logger . info ( \"Clean branch\" ) clean_disk ( branch_dir ) return work_dir create_manifest_branch ( root_dir , mirror , branch_name ) Create a manifest branch in the root_dir with the manifest branch as name. Parameters: Name Type Description Default root_dir Path Where to download the branch required mirror Union[str, pathlib.Path] Path/Link to the mirror directory or manifest URL required branch_name str Name of the branch to checkout required Returns: Type Description Path A path towards the branch work directory Source code in bgraph/builder/builder.py def create_manifest_branch ( root_dir : Path , mirror : Union [ str , Path ], branch_name : str ) -> Path : \"\"\"Create a manifest branch in the root_dir with the manifest branch as name. :param root_dir: Where to download the branch :param mirror: Path/Link to the mirror directory or manifest URL :param branch_name: Name of the branch to checkout :raises BGraphBuilderException if repo command is not found :return: A path towards the branch work directory \"\"\" branch_dir = root_dir / branch_name branch_dir . mkdir ( exist_ok = True ) # Init mirror if type ( mirror ) is str : # If it is a remote url manifest = f \" { mirror } /platform/manifest\" elif isinstance ( mirror , pathlib . Path ): manifest = str ( mirror / \"platform\" / \"manifest.git\" ) try : repo = sh . Command ( \"repo\" ) . bake ( \"--color=never\" ) except sh . CommandNotFound : logger . error ( \"Did not find repo command. Is it in PATH?\" ) raise bgraph . exc . BGraphBuilderException ( \"Repo not found.\" ) try : repo . init ( \"-u\" , f \" { manifest !s} \" , \"-b\" , branch_name , \"--partial-clone\" , \"--clone-filter=blob:none\" , \"--depth=1\" , _cwd = branch_dir , ) except sh . ErrorReturnCode : logger . error ( \"Unable to init the repository for branch %s . Verify that either the mirror\" \"is correct or the branch exists on the target.\" , branch_name , ) raise bgraph . exc . BGraphBuilderException ( \"Repo init failed.\" ) return branch_dir get_all_branches ( manifest , pattern = 'android-*' ) Parses the list of all branches available in the mirror directory This methods works for both a local manifest directory and a remote url. Returns: Type Description List[str] A list of manifest branches Source code in bgraph/builder/builder.py def get_all_branches ( manifest : Union [ Path , str ], pattern : str = \"android-*\" ) -> List [ str ]: \"\"\"Parses the list of all branches available in the mirror directory This methods works for both a local manifest directory and a remote url. :param manifest A link or a path to the manifest :param pattern A pattern to match tags in the remote directory. :return: A list of manifest branches \"\"\" if type ( manifest ) is str : manifest = f \" { manifest } /platform/manifest\" elif isinstance ( manifest , pathlib . Path ): manifest = manifest / \"platform\" / \"manifest.git\" try : tags = sh . git ( \"ls-remote\" , \"--tag\" , f \" { manifest !s} \" , pattern ) except sh . ErrorReturnCode : raise bgraph . exc . BGraphManifestException ( \"Unable to retrieve the branches.\" ) branches : List [ str ] = [] for line_encoded in tags . stdout . splitlines (): try : _ , tag = line_encoded . decode () . split ( \" \\t \" ) except ValueError : continue if tag . startswith ( \"refs/tags/\" ) and \"^\" not in tag : branches . append ( tag [ len ( \"refs/tags/\" ) :]) return branches partial_checkout ( branch_name , project_path , git_dir ) Performs a partial checkout using git. A partial checkout allows to checkout only interesting files and not the whole repository. This is a bit tricky and needs a recent git version (>2.22) Parameters: Name Type Description Default branch_name str Name of the branch required project_path Path Path where to do the checkout required git_dir Union[pathlib.Path, str] Url/Path to the git directory required Returns: Type Description bool Boolean for success Source code in bgraph/builder/builder.py def partial_checkout ( branch_name : str , project_path : Path , git_dir : Union [ Path , str ] ) -> bool : \"\"\"Performs a partial checkout using git. A partial checkout allows to checkout only interesting files and not the whole repository. This is a bit tricky and needs a recent git version (>2.22) :param branch_name: Name of the branch :param project_path: Path where to do the checkout :param git_dir: Url/Path to the git directory :return: Boolean for success \"\"\" # Guard to not redo the operation if the checkout has already been done if project_path . is_dir (): return True project_path . mkdir ( parents = True , exist_ok = True ) # Prepare the git command git = sh . git . bake ( _cwd = project_path ) # Init the directory only if .git folder is not present because git init fails on already inited git directories if not ( project_path / \".git\" ) . is_dir (): git . init () git . remote ( \"add\" , \"origin\" , f \" { git_dir !s} \" ) # Partial fetch : without objects try : git . fetch ( \"--filter=blob:none\" , \"--recurse-submodules=yes\" , \"--no-tags\" , \"--depth=1\" , \"origin\" , \"tag\" , branch_name , ) except sh . ErrorReturnCode : logger . error ( \"Unable to do the fetch part of the operation.\" ) return False # Some versions of git will fails if the .git/info/sparse-checkout is already there try : git ( \"sparse-checkout\" , \"init\" ) except sh . ErrorReturnCode : pass # Sparse checkout magic try : git ( \"sparse-checkout\" , \"set\" , \"**/*.bp\" ) git ( \"sparse-checkout\" , \"reapply\" ) git . checkout ( \"--quiet\" , f \"refs/tags/ { branch_name } \" ) except sh . ErrorReturnCode : logger . error ( \"Unable to perform sparse-checkout magic.\" ) return False # List all the files of the project (without downloading them) try : result = git ( \"ls-tree\" , \"-r\" , \"--name-only\" , f \" { branch_name } \" ) files = result . stdout . decode () . split () except sh . ErrorReturnCode : files = [] # We will need the list of files afterwards so store it try : pickle . dump ( files , open ( project_path / \"files.pickle\" , \"wb\" )) except pickle . PickleError : logger . error ( \"Unable to dump the list of files in the pickle-file.\" ) return False # Save local space: delete git folder local_dir = project_path / \".git\" if local_dir . is_dir (): shutil . rmtree ( local_dir ) return True project_checkout ( branch_name , branch_dir , mirror , paths ) Perform a project checkout. The project name is where a project is found in the mirror (e.g. MIRROR/platform/external/sqlite) The relative project path is the final path of the project in AOSP (e.g. ROOT/external/sqlite) Abort fast if no git directory is found in the mirror Parameters: Name Type Description Default branch_name str Name of the branch to checkout required branch_dir Path Branch working directory required mirror Union[str, pathlib.Path] Path/Link to a mirror required paths Tuple[pathlib.Path, pathlib.Path] Project Name and project relative path required Returns: Type Description None Source code in bgraph/builder/builder.py @bgraph . utils . no_except def project_checkout ( branch_name : str , branch_dir : Path , mirror : Union [ str , Path ], paths : Tuple [ Path , Path ], ) -> None : \"\"\"Perform a project checkout. The project name is where a project is found in the mirror (e.g. MIRROR/platform/external/sqlite) The relative project path is the final path of the project in AOSP (e.g. ROOT/external/sqlite) Abort fast if no git directory is found in the mirror :param branch_name: Name of the branch to checkout :param branch_dir: Branch working directory :param mirror: Path/Link to a mirror :param paths: Project Name and project relative path :return: \"\"\" project_name , relative_project_path = paths # Mirror git dir if type ( mirror ) is str : git_dir = f \" { mirror } / { project_name } \" elif isinstance ( mirror , pathlib . Path ): git_dir = str ( mirror / f \" { project_name } .git\" ) # AOSP project dir project_path = branch_dir / relative_project_path if isinstance ( git_dir , Path ) and not git_dir . is_dir (): logger . error ( \"Project not found ( %s )\" , git_dir ) return partial_checkout ( branch_name , project_path , git_dir ) graph Author: dm Collection of dirty scripts used to generate a source graph for AOSP based on the parsing of the Android.bp (blueprints) files. This must be used with the SoongParser developed in AOSP_BUILD project (aka acb) dependencies_keys : List [ str ] In soong files, keys that indicates a source dependency build_source_map ( sp ) From a SoongParser object, converts all the targets into a graph representation where the links between two nodes are : - a dependency link if the origin is induced in the destination - a source link if the origin is a source file and the destination a target The graphs are saved as networkx objects with pickle. Returns: Type Description DiGraph An UDG as a DiGraph Source code in bgraph/builder/graph.py def build_source_map ( sp : bgraph . parsers . soong_parser . SoongParser ) -> BGraph : \"\"\" From a SoongParser object, converts all the targets into a graph representation where the links between two nodes are : - a dependency link if the origin is induced in the destination - a source link if the origin is a source file and the destination a target The graphs are saved as networkx objects with pickle. :param: sp: The soong parser :return: An UDG as a DiGraph \"\"\" graph : BGraph = nx . DiGraph () for target in sp . sections : graph . add_node ( target , data = sp . get_section ( target )) file_listing = sp . file_listing section_files : Dict [ Path , List [ str ]] = {} nodes = list ( graph . nodes ) for idx , section_name in enumerate ( nodes ): if idx % 500 == 0 : logger . debug ( \"Converting section %d / %d \" , idx , len ( nodes )) for section in graph . nodes [ section_name ][ \"data\" ]: project_path : Path = section . get ( bgraph . parsers . soong_parser . SoongParser . SECTION_PROJECT_PATH ) project_files : List [ str ] = sp . file_listing . get ( project_path , []) if not project_files : logger . info ( f \"Cannot find files for project { section_name } \" ) convert_section ( graph , section_files , section_name , section , project_files ) return graph compute_file_list ( section_files , soong_file , project_path , files ) Create the file list that matches the soong_file for the project. WARNING: This function is not pure, it will modify in-place the section_files mapping, allowing for an easy caching. Parameters: Name Type Description Default section_files Dict[pathlib.Path, List[str]] A mapping storing the files mapping required soong_file Path Path for a soong file required project_path Path Path for a project (should be a parent of the soong file) required files List[str] List of files in the project (found via Git) required Returns: Type Description List[str] A list of files descendent of the soong file in the project Source code in bgraph/builder/graph.py def compute_file_list ( section_files : Dict [ Path , List [ str ]], soong_file : Path , project_path : Path , files : List [ str ], ) -> List [ str ]: \"\"\"Create the file list that matches the soong_file for the project. WARNING: This function is *not* pure, it will modify in-place the section_files mapping, allowing for an easy caching. :param section_files: A mapping storing the files mapping :param soong_file: Path for a soong file :param project_path: Path for a project (should be a parent of the soong file) :param files: List of files in the project (found via Git) :return: A list of files descendent of the soong file in the project \"\"\" if soong_file not in section_files : section_files [ soong_file ] = [] for file in files : full_path = project_path / file if str ( full_path ) . startswith ( str ( soong_file )): try : section_files [ soong_file ] . append ( full_path . relative_to ( soong_file ) . as_posix () ) except ValueError : pass return section_files [ soong_file ] convert ( pickle_dir , result_dir ) Iterates through the source_maps directory and convert every soong_parser objects to a NetworkX DiGraph Parameters: Name Type Description Default pickle_dir Path Path towards the file where the pickle files are stored. required result_dir Path Path where the BGraph are stored required Source code in bgraph/builder/graph.py def convert ( pickle_dir : Path , result_dir : Path ) -> None : \"\"\"Iterates through the source_maps directory and convert every soong_parser objects to a NetworkX DiGraph :param pickle_dir: Path towards the file where the pickle files are stored. :param result_dir: Path where the BGraph are stored \"\"\" to_convert : List [ Path ] = [ pickle_file for pickle_file in pickle_dir . glob ( \"*.pickle\" ) if not ( result_dir / ( pickle_file . with_suffix ( \".bgraph\" ) . name )) . is_file () ] partial_convert_single = functools . partial ( convert_single , result_dir ) with multiprocessing . Pool () as pool : res = pool . map_async ( partial_convert_single , to_convert ) results = res . get () count_success = 0 for branch_name , result in results : if result is False : logger . info ( \"Fail to convert %s \" , branch_name ) else : count_success += 1 logger . info ( \"Converted %d / %d branches\" , count_success , len ( results )) convert_section ( graph , section_files , section_name , section , project_files ) Convert a section from the SoongParser into a node in the graph and sets its dependencies Warning: This functions modifies in place the graph. Note: Some refactoring should be done on the file path detection (drop fnmatch). TODO(dm): Integrate other type of dependencies such as exclusion Parameters: Name Type Description Default graph DiGraph The UDG required section_files Dict[pathlib.Path, List[str]] A mapping for section files allowing an easy cache required section_name str Name of the section to convert required section Section Section data in iteself required project_files List[str] Files found in the source tree required Source code in bgraph/builder/graph.py def convert_section ( graph : BGraph , section_files : Dict [ Path , List [ str ]], section_name : str , section : Section , project_files : List [ str ], ) -> None : \"\"\"Convert a section from the SoongParser into a node in the graph and sets its dependencies Warning: This functions modifies in place the graph. Note: Some refactoring should be done on the file path detection (drop fnmatch). TODO(dm): Integrate other type of dependencies such as exclusion :param graph: The UDG :param section_files: A mapping for section files allowing an easy cache :param section_name: Name of the section to convert :param section: Section data in iteself :param project_files: Files found in the source tree \"\"\" # Project Path try : project_path : Path = section [ bgraph . parsers . soong_parser . SoongParser . SECTION_PROJECT_PATH ] except KeyError : logger . error ( \"Missing section_project_path in %s \" , section_name ) return # Local Soong files try : soong_file_path : Path = section [ bgraph . parsers . soong_parser . SoongParser . SOONG_FILE ] . parent except ( KeyError , AttributeError ): logger . error ( \"Missing soong_file in %s \" , section_name ) return for key , value in bgraph . utils . recurse ( section ): # type: ignore edge_type : Optional [ Literal [ \"dep\" , \"src\" ]] = None if key in dependencies_keys : edge_type = \"dep\" elif key in srcs_keys : edge_type = \"src\" if edge_type is not None : for dep in value : if edge_type == \"src\" : # For dependency key representing directories, add a * if \"dirs\" in key : dep = f \" { dep } *\" # Since we are using fnmatch and not a proper tool, we also # must take care of those prefix and remove them... # TODO(dm): Use removeprefix in Python3.9 for prefix in [ \"./\" , \".\" ]: if dep . startswith ( prefix ): dep = dep [ len ( prefix ) :] break # Resolve * in dependencies files : the pattern must be # modified to accomodate Python fnmatch module # FIX: https://android.googlesource.com/platform/build/soong/+/refs/heads/master#file-lists for dependency_file in fnmatch . filter ( compute_file_list ( section_files , soong_file_path , project_path , project_files ), dep . replace ( \"**/\" , \"*\" ), ): graph . add_edge ( str ( soong_file_path / dependency_file ), section_name , type = edge_type , ) else : graph . add_edge ( dep , section_name , type = edge_type ) convert_single ( result_dir , pickle_file ) Convert a pickle file representing a soong parser to a graph and store it in result dir. Parameters: Name Type Description Default result_dir Path Where to store the result required pickle_file Path Which file to convert required Returns: Type Description Tuple[str, bool] A tuple (branch_name, boolean for sucess) for later statistics. Source code in bgraph/builder/graph.py def convert_single ( result_dir : Path , pickle_file : Path ) -> Tuple [ str , bool ]: \"\"\"Convert a pickle file representing a soong parser to a graph and store it in result dir. :param result_dir: Where to store the result :param pickle_file: Which file to convert :return: A tuple (branch_name, boolean for sucess) for later statistics. \"\"\" branch_name : str = pickle_file . stem bgraph_file = result_dir / ( pickle_file . with_suffix ( \".bgraph\" ) . name ) try : soong_parser = pickle . load ( open ( pickle_file , \"rb\" )) except pickle . PickleError : return branch_name , False graph = build_source_map ( soong_parser ) try : with open ( bgraph_file , \"wb\" ) as file : pickle . dump ( graph , file ) except pickle . PickleError : return branch_name , False return branch_name , True","title":"builder"},{"location":"reference/builder/builder/#bgraph.builder.builder","text":"Author: dm (achallande@quarkslab.com) Create source maps for AOSP. Prerequistes: - a recent git version (>2.20) - an AOSP mirror - time","title":"builder"},{"location":"reference/builder/builder/#bgraph.builder.builder.clean_disk","text":"Remove a branch directory on the disk to save some space Parameters: Name Type Description Default branch_workdir Path Path to the directory to remove required Source code in bgraph/builder/builder.py def clean_disk ( branch_workdir : Path ) -> None : \"\"\"Remove a branch directory on the disk to save some space :param branch_workdir: Path to the directory to remove \"\"\" if branch_workdir . is_dir (): shutil . rmtree ( branch_workdir , ignore_errors = True )","title":"clean_disk()"},{"location":"reference/builder/builder/#bgraph.builder.builder.combine_files_path","text":"Load the \"files.pickle\" stored with results of git commands. Parameters: Name Type Description Default branch_dir Path Directory to find the AOSP partial tree required Returns: Type Description Dict[pathlib.Path, List[str]] A mapping of path and the list of files inside the project Source code in bgraph/builder/builder.py def combine_files_path ( branch_dir : Path ) -> Dict [ Path , List [ str ]]: \"\"\"Load the \"files.pickle\" stored with results of git commands. :param branch_dir: Directory to find the AOSP partial tree :return: A mapping of path and the list of files inside the project \"\"\" files : Dict [ Path , List [ str ]] = {} for file_path in branch_dir . rglob ( \"files.pickle\" ): try : local_files = pickle . load ( open ( file_path , \"rb\" )) except pickle . PickleError : continue files [ file_path . parent ] = local_files return files","title":"combine_files_path()"},{"location":"reference/builder/builder/#bgraph.builder.builder.compose_all","text":"Iterates through all the branches in AOSP and create the source maps. This methods: - list all the existing branches and filter those matching the pattern - does a partial checkout of each of them - parses the Soong File and store them Parameters: Name Type Description Default mirror Union[str, pathlib.Path] Path/Link to a mirror directory or an URL. required branch_pattern str Optional. Pattern to filter branches 'android-*' work_dir Optional[pathlib.Path] Optional. Work directory None force bool Optional. Overrides results. False Returns: Type Description Path The path to the work directory Source code in bgraph/builder/builder.py def compose_all ( mirror : Union [ str , Path ], branch_pattern : str = \"android-*\" , work_dir : Optional [ Path ] = None , force : bool = False , ) -> Path : \"\"\"Iterates through all the branches in AOSP and create the source maps. This methods: - list all the existing branches and filter those matching the pattern - does a partial checkout of each of them - parses the Soong File and store them :param mirror: Path/Link to a mirror directory or an URL. :param branch_pattern: Optional. Pattern to filter branches :param work_dir: Optional. Work directory :param force: Optional. Overrides results. :return: The path to the work directory \"\"\" # List branches all_branches = get_all_branches ( mirror ) branches = fnmatch . filter ( all_branches , branch_pattern ) if work_dir is None : work_dir = Path ( tempfile . mkdtemp ( prefix = \"bgraph_\" )) logger . info ( \"Found %d branches\" , len ( branches )) for branch_name in branches : compose_manifest_branch ( branch_name , mirror , work_dir , force ) logger . info ( \"Finished\" ) return work_dir","title":"compose_all()"},{"location":"reference/builder/builder/#bgraph.builder.builder.compose_manifest_branch","text":"Create the soong parser for a manifest branch. As the process is slow, multiprocessing.Pool is used to speed the checkout. The bottleneck is the parsing of blueprints files. However, since variables definition must be analyzed, we cannot just randomly parallelize this step and it must be done carefuly (read: it's not done yet.). The SoongParser is used to parse the whole tree blueprints files and stored using pickle. Another step is to convert this object as a (networkx) graph. Parameters: Name Type Description Default branch_name str Name of the branch to checkout required mirror Union[str, pathlib.Path] Path/Link towards the mirror or the manifest URL required work_dir Optional[pathlib.Path] Optional. Working directory - if not set, a temporary folder is used None force bool Optional. Overwrite existing branch. False Returns: Type Description Optional[pathlib.Path] The path to the work dir Source code in bgraph/builder/builder.py @bgraph . utils . no_except def compose_manifest_branch ( branch_name : str , mirror : Union [ str , Path ], work_dir : Optional [ Path ] = None , force : bool = False , ) -> Optional [ Path ]: \"\"\"Create the soong parser for a manifest branch. As the process is slow, multiprocessing.Pool is used to speed the checkout. The bottleneck is the parsing of blueprints files. However, since variables definition must be analyzed, we cannot just randomly parallelize this step and it must be done carefuly (read: it's not done yet.). The SoongParser is used to parse the whole tree blueprints files and stored using pickle. Another step is to convert this object as a (networkx) graph. :param branch_name: Name of the branch to checkout :param mirror: Path/Link towards the mirror or the manifest URL :param work_dir: Optional. Working directory - if not set, a temporary folder is used :param force: Optional. Overwrite existing branch. :return: The path to the work dir \"\"\" logger . info ( \"Start composing for %s \" , branch_name ) if work_dir is None : work_dir = Path ( tempfile . mkdtemp ( prefix = \"bgraph_\" )) # Guard: do not redo a branch pickle_file = work_dir / f \" { branch_name } .pickle\" if pickle_file . is_file () and force is False : logger . info ( \"Branch already found; skip.\" ) return work_dir elif ( work_dir / f \" { branch_name } .empty\" ) . is_file (): logger . info ( \"Branch empty; skip.\" ) return work_dir # Create a branch by using repo try : branch_dir = create_manifest_branch ( work_dir , mirror , branch_name ) except bgraph . exc . BGraphBuilderException : return None manifest_file = branch_dir / \".repo\" / \"manifests\" / \"default.xml\" logger . info ( \"List projects\" ) project_checkout_branch = functools . partial ( project_checkout , branch_name , branch_dir , mirror ) # Load the manifest manifest = bgraph . parsers . Manifest . from_file ( manifest_file ) # Core: multiprocessing with multiprocessing . Pool () as pool : res = pool . map_async ( project_checkout_branch , manifest . get_projects () . items ()) res . get ( 24 * 60 * 60 ) logger . info ( \"Finished to compose with %s \" , branch_name ) # Guard: Search build files for _ in branch_dir . rglob ( \"Android.bp\" ): break else : logger . info ( \"Found 0 Android.bp file, aborting\" ) # Create an empty file to prevent from doing it if we restart with open ( work_dir / f \" { branch_name } .empty\" , \"w\" ) as _ : pass clean_disk ( branch_dir ) return work_dir soong_parser = bgraph . parsers . SoongParser () logger . info ( \"Starting parsing AOSP build files\" ) soong_parser . parse_aosp ( branch_dir , project_map = manifest . get_projects ()) soong_parser . file_listing = combine_files_path ( branch_dir ) # Save the result try : pickle . dump ( soong_parser , open ( pickle_file , \"wb\" )) except pickle . PickleError : logger . error ( \"Failed to pickle\" ) clean_disk ( branch_dir ) return work_dir # Clean the disk logger . info ( \"Clean branch\" ) clean_disk ( branch_dir ) return work_dir","title":"compose_manifest_branch()"},{"location":"reference/builder/builder/#bgraph.builder.builder.create_manifest_branch","text":"Create a manifest branch in the root_dir with the manifest branch as name. Parameters: Name Type Description Default root_dir Path Where to download the branch required mirror Union[str, pathlib.Path] Path/Link to the mirror directory or manifest URL required branch_name str Name of the branch to checkout required Returns: Type Description Path A path towards the branch work directory Source code in bgraph/builder/builder.py def create_manifest_branch ( root_dir : Path , mirror : Union [ str , Path ], branch_name : str ) -> Path : \"\"\"Create a manifest branch in the root_dir with the manifest branch as name. :param root_dir: Where to download the branch :param mirror: Path/Link to the mirror directory or manifest URL :param branch_name: Name of the branch to checkout :raises BGraphBuilderException if repo command is not found :return: A path towards the branch work directory \"\"\" branch_dir = root_dir / branch_name branch_dir . mkdir ( exist_ok = True ) # Init mirror if type ( mirror ) is str : # If it is a remote url manifest = f \" { mirror } /platform/manifest\" elif isinstance ( mirror , pathlib . Path ): manifest = str ( mirror / \"platform\" / \"manifest.git\" ) try : repo = sh . Command ( \"repo\" ) . bake ( \"--color=never\" ) except sh . CommandNotFound : logger . error ( \"Did not find repo command. Is it in PATH?\" ) raise bgraph . exc . BGraphBuilderException ( \"Repo not found.\" ) try : repo . init ( \"-u\" , f \" { manifest !s} \" , \"-b\" , branch_name , \"--partial-clone\" , \"--clone-filter=blob:none\" , \"--depth=1\" , _cwd = branch_dir , ) except sh . ErrorReturnCode : logger . error ( \"Unable to init the repository for branch %s . Verify that either the mirror\" \"is correct or the branch exists on the target.\" , branch_name , ) raise bgraph . exc . BGraphBuilderException ( \"Repo init failed.\" ) return branch_dir","title":"create_manifest_branch()"},{"location":"reference/builder/builder/#bgraph.builder.builder.get_all_branches","text":"Parses the list of all branches available in the mirror directory This methods works for both a local manifest directory and a remote url. Returns: Type Description List[str] A list of manifest branches Source code in bgraph/builder/builder.py def get_all_branches ( manifest : Union [ Path , str ], pattern : str = \"android-*\" ) -> List [ str ]: \"\"\"Parses the list of all branches available in the mirror directory This methods works for both a local manifest directory and a remote url. :param manifest A link or a path to the manifest :param pattern A pattern to match tags in the remote directory. :return: A list of manifest branches \"\"\" if type ( manifest ) is str : manifest = f \" { manifest } /platform/manifest\" elif isinstance ( manifest , pathlib . Path ): manifest = manifest / \"platform\" / \"manifest.git\" try : tags = sh . git ( \"ls-remote\" , \"--tag\" , f \" { manifest !s} \" , pattern ) except sh . ErrorReturnCode : raise bgraph . exc . BGraphManifestException ( \"Unable to retrieve the branches.\" ) branches : List [ str ] = [] for line_encoded in tags . stdout . splitlines (): try : _ , tag = line_encoded . decode () . split ( \" \\t \" ) except ValueError : continue if tag . startswith ( \"refs/tags/\" ) and \"^\" not in tag : branches . append ( tag [ len ( \"refs/tags/\" ) :]) return branches","title":"get_all_branches()"},{"location":"reference/builder/builder/#bgraph.builder.builder.partial_checkout","text":"Performs a partial checkout using git. A partial checkout allows to checkout only interesting files and not the whole repository. This is a bit tricky and needs a recent git version (>2.22) Parameters: Name Type Description Default branch_name str Name of the branch required project_path Path Path where to do the checkout required git_dir Union[pathlib.Path, str] Url/Path to the git directory required Returns: Type Description bool Boolean for success Source code in bgraph/builder/builder.py def partial_checkout ( branch_name : str , project_path : Path , git_dir : Union [ Path , str ] ) -> bool : \"\"\"Performs a partial checkout using git. A partial checkout allows to checkout only interesting files and not the whole repository. This is a bit tricky and needs a recent git version (>2.22) :param branch_name: Name of the branch :param project_path: Path where to do the checkout :param git_dir: Url/Path to the git directory :return: Boolean for success \"\"\" # Guard to not redo the operation if the checkout has already been done if project_path . is_dir (): return True project_path . mkdir ( parents = True , exist_ok = True ) # Prepare the git command git = sh . git . bake ( _cwd = project_path ) # Init the directory only if .git folder is not present because git init fails on already inited git directories if not ( project_path / \".git\" ) . is_dir (): git . init () git . remote ( \"add\" , \"origin\" , f \" { git_dir !s} \" ) # Partial fetch : without objects try : git . fetch ( \"--filter=blob:none\" , \"--recurse-submodules=yes\" , \"--no-tags\" , \"--depth=1\" , \"origin\" , \"tag\" , branch_name , ) except sh . ErrorReturnCode : logger . error ( \"Unable to do the fetch part of the operation.\" ) return False # Some versions of git will fails if the .git/info/sparse-checkout is already there try : git ( \"sparse-checkout\" , \"init\" ) except sh . ErrorReturnCode : pass # Sparse checkout magic try : git ( \"sparse-checkout\" , \"set\" , \"**/*.bp\" ) git ( \"sparse-checkout\" , \"reapply\" ) git . checkout ( \"--quiet\" , f \"refs/tags/ { branch_name } \" ) except sh . ErrorReturnCode : logger . error ( \"Unable to perform sparse-checkout magic.\" ) return False # List all the files of the project (without downloading them) try : result = git ( \"ls-tree\" , \"-r\" , \"--name-only\" , f \" { branch_name } \" ) files = result . stdout . decode () . split () except sh . ErrorReturnCode : files = [] # We will need the list of files afterwards so store it try : pickle . dump ( files , open ( project_path / \"files.pickle\" , \"wb\" )) except pickle . PickleError : logger . error ( \"Unable to dump the list of files in the pickle-file.\" ) return False # Save local space: delete git folder local_dir = project_path / \".git\" if local_dir . is_dir (): shutil . rmtree ( local_dir ) return True","title":"partial_checkout()"},{"location":"reference/builder/builder/#bgraph.builder.builder.project_checkout","text":"Perform a project checkout. The project name is where a project is found in the mirror (e.g. MIRROR/platform/external/sqlite) The relative project path is the final path of the project in AOSP (e.g. ROOT/external/sqlite) Abort fast if no git directory is found in the mirror Parameters: Name Type Description Default branch_name str Name of the branch to checkout required branch_dir Path Branch working directory required mirror Union[str, pathlib.Path] Path/Link to a mirror required paths Tuple[pathlib.Path, pathlib.Path] Project Name and project relative path required Returns: Type Description None Source code in bgraph/builder/builder.py @bgraph . utils . no_except def project_checkout ( branch_name : str , branch_dir : Path , mirror : Union [ str , Path ], paths : Tuple [ Path , Path ], ) -> None : \"\"\"Perform a project checkout. The project name is where a project is found in the mirror (e.g. MIRROR/platform/external/sqlite) The relative project path is the final path of the project in AOSP (e.g. ROOT/external/sqlite) Abort fast if no git directory is found in the mirror :param branch_name: Name of the branch to checkout :param branch_dir: Branch working directory :param mirror: Path/Link to a mirror :param paths: Project Name and project relative path :return: \"\"\" project_name , relative_project_path = paths # Mirror git dir if type ( mirror ) is str : git_dir = f \" { mirror } / { project_name } \" elif isinstance ( mirror , pathlib . Path ): git_dir = str ( mirror / f \" { project_name } .git\" ) # AOSP project dir project_path = branch_dir / relative_project_path if isinstance ( git_dir , Path ) and not git_dir . is_dir (): logger . error ( \"Project not found ( %s )\" , git_dir ) return partial_checkout ( branch_name , project_path , git_dir )","title":"project_checkout()"},{"location":"reference/builder/builder/#bgraph.builder.graph","text":"Author: dm Collection of dirty scripts used to generate a source graph for AOSP based on the parsing of the Android.bp (blueprints) files. This must be used with the SoongParser developed in AOSP_BUILD project (aka acb)","title":"graph"},{"location":"reference/builder/builder/#bgraph.builder.graph.dependencies_keys","text":"In soong files, keys that indicates a source dependency","title":"dependencies_keys"},{"location":"reference/builder/builder/#bgraph.builder.graph.build_source_map","text":"From a SoongParser object, converts all the targets into a graph representation where the links between two nodes are : - a dependency link if the origin is induced in the destination - a source link if the origin is a source file and the destination a target The graphs are saved as networkx objects with pickle. Returns: Type Description DiGraph An UDG as a DiGraph Source code in bgraph/builder/graph.py def build_source_map ( sp : bgraph . parsers . soong_parser . SoongParser ) -> BGraph : \"\"\" From a SoongParser object, converts all the targets into a graph representation where the links between two nodes are : - a dependency link if the origin is induced in the destination - a source link if the origin is a source file and the destination a target The graphs are saved as networkx objects with pickle. :param: sp: The soong parser :return: An UDG as a DiGraph \"\"\" graph : BGraph = nx . DiGraph () for target in sp . sections : graph . add_node ( target , data = sp . get_section ( target )) file_listing = sp . file_listing section_files : Dict [ Path , List [ str ]] = {} nodes = list ( graph . nodes ) for idx , section_name in enumerate ( nodes ): if idx % 500 == 0 : logger . debug ( \"Converting section %d / %d \" , idx , len ( nodes )) for section in graph . nodes [ section_name ][ \"data\" ]: project_path : Path = section . get ( bgraph . parsers . soong_parser . SoongParser . SECTION_PROJECT_PATH ) project_files : List [ str ] = sp . file_listing . get ( project_path , []) if not project_files : logger . info ( f \"Cannot find files for project { section_name } \" ) convert_section ( graph , section_files , section_name , section , project_files ) return graph","title":"build_source_map()"},{"location":"reference/builder/builder/#bgraph.builder.graph.compute_file_list","text":"Create the file list that matches the soong_file for the project. WARNING: This function is not pure, it will modify in-place the section_files mapping, allowing for an easy caching. Parameters: Name Type Description Default section_files Dict[pathlib.Path, List[str]] A mapping storing the files mapping required soong_file Path Path for a soong file required project_path Path Path for a project (should be a parent of the soong file) required files List[str] List of files in the project (found via Git) required Returns: Type Description List[str] A list of files descendent of the soong file in the project Source code in bgraph/builder/graph.py def compute_file_list ( section_files : Dict [ Path , List [ str ]], soong_file : Path , project_path : Path , files : List [ str ], ) -> List [ str ]: \"\"\"Create the file list that matches the soong_file for the project. WARNING: This function is *not* pure, it will modify in-place the section_files mapping, allowing for an easy caching. :param section_files: A mapping storing the files mapping :param soong_file: Path for a soong file :param project_path: Path for a project (should be a parent of the soong file) :param files: List of files in the project (found via Git) :return: A list of files descendent of the soong file in the project \"\"\" if soong_file not in section_files : section_files [ soong_file ] = [] for file in files : full_path = project_path / file if str ( full_path ) . startswith ( str ( soong_file )): try : section_files [ soong_file ] . append ( full_path . relative_to ( soong_file ) . as_posix () ) except ValueError : pass return section_files [ soong_file ]","title":"compute_file_list()"},{"location":"reference/builder/builder/#bgraph.builder.graph.convert","text":"Iterates through the source_maps directory and convert every soong_parser objects to a NetworkX DiGraph Parameters: Name Type Description Default pickle_dir Path Path towards the file where the pickle files are stored. required result_dir Path Path where the BGraph are stored required Source code in bgraph/builder/graph.py def convert ( pickle_dir : Path , result_dir : Path ) -> None : \"\"\"Iterates through the source_maps directory and convert every soong_parser objects to a NetworkX DiGraph :param pickle_dir: Path towards the file where the pickle files are stored. :param result_dir: Path where the BGraph are stored \"\"\" to_convert : List [ Path ] = [ pickle_file for pickle_file in pickle_dir . glob ( \"*.pickle\" ) if not ( result_dir / ( pickle_file . with_suffix ( \".bgraph\" ) . name )) . is_file () ] partial_convert_single = functools . partial ( convert_single , result_dir ) with multiprocessing . Pool () as pool : res = pool . map_async ( partial_convert_single , to_convert ) results = res . get () count_success = 0 for branch_name , result in results : if result is False : logger . info ( \"Fail to convert %s \" , branch_name ) else : count_success += 1 logger . info ( \"Converted %d / %d branches\" , count_success , len ( results ))","title":"convert()"},{"location":"reference/builder/builder/#bgraph.builder.graph.convert_section","text":"Convert a section from the SoongParser into a node in the graph and sets its dependencies Warning: This functions modifies in place the graph. Note: Some refactoring should be done on the file path detection (drop fnmatch). TODO(dm): Integrate other type of dependencies such as exclusion Parameters: Name Type Description Default graph DiGraph The UDG required section_files Dict[pathlib.Path, List[str]] A mapping for section files allowing an easy cache required section_name str Name of the section to convert required section Section Section data in iteself required project_files List[str] Files found in the source tree required Source code in bgraph/builder/graph.py def convert_section ( graph : BGraph , section_files : Dict [ Path , List [ str ]], section_name : str , section : Section , project_files : List [ str ], ) -> None : \"\"\"Convert a section from the SoongParser into a node in the graph and sets its dependencies Warning: This functions modifies in place the graph. Note: Some refactoring should be done on the file path detection (drop fnmatch). TODO(dm): Integrate other type of dependencies such as exclusion :param graph: The UDG :param section_files: A mapping for section files allowing an easy cache :param section_name: Name of the section to convert :param section: Section data in iteself :param project_files: Files found in the source tree \"\"\" # Project Path try : project_path : Path = section [ bgraph . parsers . soong_parser . SoongParser . SECTION_PROJECT_PATH ] except KeyError : logger . error ( \"Missing section_project_path in %s \" , section_name ) return # Local Soong files try : soong_file_path : Path = section [ bgraph . parsers . soong_parser . SoongParser . SOONG_FILE ] . parent except ( KeyError , AttributeError ): logger . error ( \"Missing soong_file in %s \" , section_name ) return for key , value in bgraph . utils . recurse ( section ): # type: ignore edge_type : Optional [ Literal [ \"dep\" , \"src\" ]] = None if key in dependencies_keys : edge_type = \"dep\" elif key in srcs_keys : edge_type = \"src\" if edge_type is not None : for dep in value : if edge_type == \"src\" : # For dependency key representing directories, add a * if \"dirs\" in key : dep = f \" { dep } *\" # Since we are using fnmatch and not a proper tool, we also # must take care of those prefix and remove them... # TODO(dm): Use removeprefix in Python3.9 for prefix in [ \"./\" , \".\" ]: if dep . startswith ( prefix ): dep = dep [ len ( prefix ) :] break # Resolve * in dependencies files : the pattern must be # modified to accomodate Python fnmatch module # FIX: https://android.googlesource.com/platform/build/soong/+/refs/heads/master#file-lists for dependency_file in fnmatch . filter ( compute_file_list ( section_files , soong_file_path , project_path , project_files ), dep . replace ( \"**/\" , \"*\" ), ): graph . add_edge ( str ( soong_file_path / dependency_file ), section_name , type = edge_type , ) else : graph . add_edge ( dep , section_name , type = edge_type )","title":"convert_section()"},{"location":"reference/builder/builder/#bgraph.builder.graph.convert_single","text":"Convert a pickle file representing a soong parser to a graph and store it in result dir. Parameters: Name Type Description Default result_dir Path Where to store the result required pickle_file Path Which file to convert required Returns: Type Description Tuple[str, bool] A tuple (branch_name, boolean for sucess) for later statistics. Source code in bgraph/builder/graph.py def convert_single ( result_dir : Path , pickle_file : Path ) -> Tuple [ str , bool ]: \"\"\"Convert a pickle file representing a soong parser to a graph and store it in result dir. :param result_dir: Where to store the result :param pickle_file: Which file to convert :return: A tuple (branch_name, boolean for sucess) for later statistics. \"\"\" branch_name : str = pickle_file . stem bgraph_file = result_dir / ( pickle_file . with_suffix ( \".bgraph\" ) . name ) try : soong_parser = pickle . load ( open ( pickle_file , \"rb\" )) except pickle . PickleError : return branch_name , False graph = build_source_map ( soong_parser ) try : with open ( bgraph_file , \"wb\" ) as file : pickle . dump ( graph , file ) except pickle . PickleError : return branch_name , False return branch_name , True","title":"convert_single()"},{"location":"reference/parsers/parsers/","text":"soong_parser logger : Logger Logger. Manifest A Manifest (for AOSP) is an XML file listing all the projects used for a version of AOSP. The repository listing all the manifests is found at : https://android.googlesource.com/platform/manifest/ This classes is a light wrapper around the XML File to query the parts of the manifest we are interested into. Parameters: Name Type Description Default manifest_content The content of a manifest required __init__ ( self , manifest_content ) special Constructor method Source code in bgraph/parsers/soong_parser.py def __init__ ( self , manifest_content : str ) -> None : \"\"\"Constructor method\"\"\" try : self . xml : untangle . Element = untangle . parse ( manifest_content ) except xml . sax . SAXParseException as e : logger . exception ( e ) raise bgraph . exc . BGraphManifestException ( \"Unable to load the manifest\" ) if ( getattr ( self . xml , \"manifest\" , False ) is False or getattr ( self . xml . manifest , \"project\" , False ) is False ): raise bgraph . exc . BGraphManifestException ( \"Manifest misformed\" ) from_file ( file_path ) classmethod Load a Manifest from a file Parameters: Name Type Description Default file_path Union[str, pathlib.Path] A PathLike object pointing to a file. required Returns: Type Description Manifest A Manifest class. Source code in bgraph/parsers/soong_parser.py @classmethod def from_file ( cls , file_path : Union [ str , pathlib . Path ]) -> \"Manifest\" : \"\"\"Load a Manifest from a file :param file_path: A PathLike object pointing to a file. :return: A `Manifest` class. \"\"\" file_path = pathlib . Path ( file_path ) if file_path . is_file (): return cls ( manifest_content = file_path . as_posix ()) raise bgraph . exc . BGraphManifestException () from_url ( manifest_name , other_url = None ) classmethod Loads a manifest from an URL Warning: This methods parses arbitrary data from an URL. Use with caution <!> If the other_url parameter is set, this will be used as an absolute URL. Otherwise, it will fetch data from the googlesource servers. Parameters: Name Type Description Default manifest_name str Name of the manifest required other_url Optional[str] Use this url and not the one from Google None Returns: Type Description Manifest A Manifest class Source code in bgraph/parsers/soong_parser.py @classmethod def from_url ( cls , manifest_name : str , other_url : Optional [ str ] = None ) -> \"Manifest\" : \"\"\"Loads a manifest from an URL Warning: This methods parses arbitrary data from an URL. Use with caution <!> If the other_url parameter is set, this will be used as an absolute URL. Otherwise, it will fetch data from the googlesource servers. :param manifest_name: Name of the manifest :param other_url: Use this url and not the one from Google :return: A `Manifest` class \"\"\" try : import requests except ImportError : raise bgraph . exc . BGraphManifestException ( \"Must have requests installed for this action\" ) if other_url is None : url_content = f \"https://android.googlesource.com/platform/manifest/+/refs/heads/ { manifest_name } /default.xml?format=TEXT\" else : url_content = other_url try : response = requests . get ( url_content ) except requests . exceptions . RequestException as e : raise bgraph . exc . BGraphManifestException ( e ) try : xml_string : str = base64 . decodebytes ( response . content ) . decode ( response . encoding ) except TypeError as e : raise bgraph . exc . BGraphManifestException ( e ) return cls ( manifest_content = xml_string ) get_projects ( self ) Returns the list of the projects for a manifest. Returns: Type Description Dict[str, str] A mapping between project name and project paths Source code in bgraph/parsers/soong_parser.py def get_projects ( self ) -> Dict [ str , str ]: \"\"\"Returns the list of the projects for a manifest. :return: A mapping between project name and project paths \"\"\" project_map : Dict [ str , str ] = {} for project in self . xml . manifest . project : project_name = project [ \"name\" ] project_path = project [ \"path\" ] if project_name is not None and project_path is not None : project_map [ project_name ] = project_path else : logger . warning ( \"Projet %s (@path: %s ) is None\" , project_name , project_path ) return project_map SoongFileParser Parser for soong files Set and parse a soong file. This is a best effort parser and some edge cases are not supported. Parameters: Name Type Description Default (Dict) variables Mapping of variables and their value inside the Blueprint file required __init__ ( self , file_path = None , variables = None ) special Constructor Source code in bgraph/parsers/soong_parser.py def __init__ ( self , file_path : Optional [ Union [ pathlib . Path , str ]] = None , variables : Dict [ str , Any ] = None , ): \"\"\"Constructor\"\"\" self . variables : Dict [ str , Any ] = {} if variables is not None : self . variables = variables self . identifiers : Dict [ str , Any ] = {} self . sections : Dict [ str , List [ Section ]] = collections . defaultdict ( list ) self . parser : pyparsing . ParserElement = self . _init_parser () if file_path : self . parser . parseFile ( pathlib . Path ( file_path ) . as_posix ()) if self . identifiers or not ( self . sections or self . variables ): raise bgraph . exc . BGraphParserException ( \"An error ocured during parsing\" ) parse_boolean ( tokens ) staticmethod Helper method to parse boolean Parameters: Name Type Description Default tokens List[Any] List of tokens required Returns: Type Description bool A boolean Exceptions: Type Description BGraphParserException When the boolean is not true or false Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_boolean ( tokens : List [ Any ]) -> bool : \"\"\"Helper method to parse boolean :param tokens: List of tokens :raises BGraphParserException: When the boolean is not true or false :return: A boolean \"\"\" token = tokens [ 0 ] if token == \"true\" : return True elif token == \"false\" : return False raise bgraph . exc . BGraphParserException ( \"Boolean exception\" ) parse_dict_def ( tokens ) staticmethod Helper method to parse the dict definition Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_dict_def ( tokens ) -> Dict : \"\"\"Helper method to parse the dict definition\"\"\" result_dict = {} for token in tokens : result_dict . update ( token ) return result_dict parse_dict_field ( tokens ) staticmethod Helper method to parse a map Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_dict_field ( tokens ) -> Dict : \"\"\"Helper method to parse a map\"\"\" key = tokens [ 0 ] val = tokens [ 1 ] if len ( tokens ) == 2 else tokens [ 1 :] return { key : val } parse_integer ( tokens ) staticmethod Helper method to parse integers Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description int An integer Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_integer ( tokens : List [ str ]) -> int : \"\"\"Helper method to parse integers :param tokens: Tokens :return: An integer \"\"\" return int ( tokens [ 0 ]) parse_list_concat ( tokens ) staticmethod Helper for list concatenation Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description List[Any] A list of tokens Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_list_concat ( tokens : List [ str ]) -> List [ Any ]: \"\"\"Helper for list concatenation :param tokens: Tokens :return: A list of tokens \"\"\" final_list : List [ Any ] = [] for token in tokens : if type ( token ) is list : final_list . extend ( token ) elif type ( token ) is str : final_list . append ( token ) else : # Do not raise an exception as it may mess with pyparsing return [] return final_list parse_section ( self , tokens ) Parse a section Parameters: Name Type Description Default tokens List[str] Tokens required Exceptions: Type Description BGraphParserException If the parsing of the section fails Source code in bgraph/parsers/soong_parser.py def parse_section ( self , tokens : List [ str ]) -> None : \"\"\"Parse a section :param tokens: Tokens :raises BGraphParserException: If the parsing of the section fails \"\"\" section_name = None section_dict : Section = { SoongParser . SECTION_TYPE : tokens [ 0 ]} for token in tokens [ 1 :]: if token in self . identifiers : if token == \"name\" : section_name = self . identifiers [ token ] else : # TODO(dm) This will be resolved when we have a way to type hint a # dict with dynamic values section_dict [ token ] = self . identifiers [ token ] # type: ignore del self . identifiers [ token ] else : raise bgraph . exc . BGraphParserException ( \"Missing key {} in section {} \" . format ( token , section_name ) ) # Each section *must* have a name if section_name is None : # Except soong_namespace ... if section_dict [ SoongParser . SECTION_TYPE ] in ( \"soong_namespace\" ,): logger . debug ( \"Found a soong namespace but it is not supported yet.\" ) return raise bgraph . exc . BGraphParserException ( \"Section has no attribute name\" ) self . sections [ section_name ] . append ( section_dict ) parse_section_field ( self , tokens ) Parse a section field Example: name: \"libartbase_defaults\" Source code in bgraph/parsers/soong_parser.py def parse_section_field ( self , tokens : List [ str ]) -> str : \"\"\"Parse a section field Example: name: \"libartbase_defaults\" :return The name of the field \"\"\" if len ( tokens ) == 2 : self . identifiers [ tokens [ 0 ]] = tokens [ 1 ] elif len ( tokens ) > 2 : self . identifiers [ tokens [ 0 ]] = tokens [ 1 :] elif len ( tokens ) == 1 : # FIX: handle empty definitions like whole_static_libs: [] self . identifiers [ tokens [ 0 ]] = [] return tokens [ 0 ] parse_string_concat ( tokens ) staticmethod Helper method to concat string together Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description Optional[str] Optionnaly a string string Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_string_concat ( tokens : List [ str ]) -> Optional [ str ]: \"\"\"Helper method to concat string together :param tokens: Tokens :return: Optionnaly a string string \"\"\" final_token = \"\" for token in tokens : if type ( token ) is str : final_token += token else : # Do not raise an exception as it may mess up with pyparsing return None return final_token parse_variable_def ( self , _ , __ , tokens , append = False ) Helper method to parse variable definition Parameters: Name Type Description Default _ N/A required __ N/A required tokens List[Any] Tokens to parse required append bool Should we appended the value to the existing one or not False Exceptions: Type Description BGraphParserException When the parsing fails Source code in bgraph/parsers/soong_parser.py def parse_variable_def ( self , _ , __ , tokens : List [ Any ], append : bool = False ) -> None : \"\"\"Helper method to parse variable definition :param _: N/A :param __: N/A :param tokens: Tokens to parse :param append: Should we appended the value to the existing one or not :raises BGraphParserException: When the parsing fails \"\"\" variable_name = tokens [ 0 ] new_value = tokens [ 1 ] if len ( tokens ) == 2 else tokens [ 1 :] if append is False : old_value = self . variables . get ( variable_name , None ) if old_value is not None and old_value != new_value : logger . debug ( \"Overwritting variable - in debug, check if legit.\" ) # raise bgraph.exc.BGraphParserException(\"Conflicting variables names\") self . variables [ variable_name ] = new_value else : actual_value = self . variables . get ( variable_name ) if actual_value is None : raise bgraph . exc . BGraphParserException ( \"Missing previous variable during append\" ) if type ( new_value ) != type ( actual_value ): new_value = [ new_value ] if type ( new_value ) is str else new_value actual_value = ( [ actual_value ] if type ( actual_value ) is str else actual_value ) self . variables [ variable_name ] = actual_value + new_value parse_variable_ref ( self , tokens ) Helper method to parse variable reference Parameters: Name Type Description Default tokens List[str] Tokens to parse required Returns: Type Description Any The variable value Source code in bgraph/parsers/soong_parser.py def parse_variable_ref ( self , tokens : List [ str ]) -> Any : \"\"\"Helper method to parse variable reference :param tokens: Tokens to parse :raises: BGraphParserException When the variables is used before being defined :return: The variable value \"\"\" var_name : str = tokens [ 0 ] if var_name not in self . variables : raise bgraph . exc . BGraphParserException ( \"Missing variable ref var_name\" ) return self . variables [ var_name ] SoongParser Soong Parser This is the wrapper around the parser for Soong file (e.g. Android.bp) Every section will be augmented with special keys (always prefixed with soong_parser). DEFAULT_FILENAME : Final Default name for Soong file. file_listing : Dict [ pathlib . Path , List [ str ]] property writable A map of every paths and files inside the project. This is used to resolve wildcards in filenames for Soong. Returns: Type Description Dict[pathlib.Path, List[str]] A maping between path and list of files inside an AOSP tree. NATIVE_TYPES : List [ str ] Type of section considered as \"natives\". SECTION_PROJECT : Final Name of the project for the current section. SECTION_PROJECT_PATH : Final Absolute path of the project in AOSP root tree. SECTION_TYPE : Final Type of the section (e.g. cc_library). SOONG_FILE : Final Absolute path of the Soong file in AOSP root tree. __init__ ( self ) special Init method. Source code in bgraph/parsers/soong_parser.py def __init__ ( self ) -> None : \"\"\"Init method.\"\"\" self . sections : Dict [ str , List [ Section ]] = collections . defaultdict ( list ) self . variables : Dict [ str , Any ] = {} self . _files_listing : Dict [ pathlib . Path , List [ str ]] = {} get_section ( self , section_name , section_type = None ) Get a section from the project. This is the main method of the class. It will also resolve the section defaults if any are found. Note that the name must be exact. Parameters: Name Type Description Default section_name str Name of the section required section_type Optional[str] Optional. Type of the section. If the type is defined, a single section will be returned of matching type. Otherwise all sections having the same name will be returned. None Returns: Type Description Union[List[bgraph.types.Section], bgraph.types.Section] A (list of) sections having the name asked. Source code in bgraph/parsers/soong_parser.py def get_section ( self , section_name : str , section_type : Optional [ str ] = None ) -> Union [ List [ Section ], Section ]: \"\"\"Get a section from the project. This is the main method of the class. It will also resolve the section defaults if any are found. Note that the name *must* be exact. :param section_name: Name of the section :param section_type: Optional. Type of the section. If the type is defined, a single section will be returned of matching type. Otherwise all sections having the same name will be returned. :return: A (list of) sections having the name asked. \"\"\" sections : List [ Section ] = self . _retrieve_section ( section_name ) if section_type is None : return sections for section in sections : if section [ self . SECTION_TYPE ] == section_type : return section raise bgraph . exc . BGraphMissingSectionException () get_targets ( self ) Compute the list of targets. A section is considered to be a target if the section_type is a binary type. This method is for now pretty simplist but could be improved. TODO: - add target parameter to filter targets - Filter also according to the value for the arch - add multi arch support - host/target difference Returns: Type Description List[str] A list of section having a \"binary\" target. Source code in bgraph/parsers/soong_parser.py def get_targets ( self ) -> List [ str ]: \"\"\"Compute the list of targets. A section is considered to be a target if the section_type is a binary type. This method is for now pretty simplist but could be improved. TODO: - add target parameter to filter targets - Filter also according to the value for the arch - add multi arch support - host/target difference :return: A list of section having a \"binary\" target. \"\"\" target_list : List [ str ] = [] for section_name in self . list_section ( with_defaults = False ): section_map : List [ Section ] = self . get_section ( section_name ) for section in section_map : section_type = section . get ( self . SECTION_TYPE ) if section_type in [ \"cc_library\" , \"cc_library_shared\" , \"cc_library_static\" , ]: # The target is actually the name of the section. Manual says it can # be overriden but I did not find any evidence of that. # TODO(dm) : see if the name if overriden & check if the lib is not # disabled for target ? (how?) target_list . append ( section_name ) elif section_type in [ \"cc_binary\" , ]: target_list . append ( section_name ) return target_list list_section ( self , with_defaults = False ) List sections found in AOSP. Parameters: Name Type Description Default with_defaults bool Also include defaults sections in the results False Returns: Type Description List[str] A list of sections Source code in bgraph/parsers/soong_parser.py def list_section ( self , with_defaults : bool = False ) -> List [ str ]: \"\"\"List sections found in AOSP. :param with_defaults: Also include defaults sections in the results :return: A list of sections \"\"\" section_list : List [ str ] = [] for section_name , targets in self . sections . items (): if with_defaults or any ( \"default\" not in target . get ( self . SECTION_TYPE , \"\" ) for target in targets ): section_list . append ( section_name ) return section_list parse_aosp ( self , aosp_directory , file_name = None , project_map = None ) Parses an AOSP tree. This methods only needs the soong file to be present so a partial checkout is enough to create the listing. The project map is needed because it needs to know the root tree of a project. Parameters: Name Type Description Default aosp_directory Union[str, pathlib.Path] Root tree of AOSP required file_name Optional[str] Optional Name of file None project_map Dict A map of project name / project path None Source code in bgraph/parsers/soong_parser.py def parse_aosp ( self , aosp_directory : Union [ str , pathlib . Path ], file_name : Optional [ str ] = None , project_map : Dict = None , ) -> None : \"\"\"Parses an AOSP tree. This methods only needs the soong file to be present so a partial checkout is enough to create the listing. The project map is needed because it needs to know the root tree of a project. :param aosp_directory: Root tree of AOSP :param file_name: Optional Name of file :param project_map: A map of project name / project path \"\"\" if file_name is None : file_name = self . DEFAULT_FILENAME if project_map is None : raise bgraph . exc . BGraphParserException ( \"Missing project map.\" ) aosp_directory = pathlib . Path ( aosp_directory ) for project_name , relative_path in project_map . items (): project_path = aosp_directory / relative_path self . parse_project ( project_directory = project_path , file_name = file_name , project_name = project_name , ) parse_file ( self , file_path , project_name = None , project_path = None , project_variables = None ) Parse a file (e.g. an Android.bp) and update the current class. Note: This will silently fails if the file is misformed. Parameters: Name Type Description Default file_path Union[str, pathlib.Path] Path towards the file required project_name str Optional. Name of the current project None project_path Optional[pathlib.Path] Optional. Path to the root of the project None project_variables Dict[str, Any] Variables already set for the project None Source code in bgraph/parsers/soong_parser.py def parse_file ( self , file_path : Union [ str , pathlib . Path ], project_name : str = None , project_path : Optional [ pathlib . Path ] = None , project_variables : Dict [ str , Any ] = None , ) -> None : \"\"\"Parse a file (e.g. an Android.bp) and update the current class. Note: This will silently fails if the file is misformed. :param file_path: Path towards the file :param project_name: Optional. Name of the current project :param project_path: Optional. Path to the root of the project :param project_variables: Variables already set for the project \"\"\" if project_variables is None : project_variables = {} try : parser = SoongFileParser ( file_path , project_variables ) except bgraph . exc . BGraphParserException : # The parser is a best effort one. If it fails, do not try to hard but # report the error if in DEBUG mode. logger . debug ( \"Failed to parse %s \" , file_path ) return # If we are doing a parsing of a project, we want to store more information on # the sections, namely where was the initial file located and the root source of # the project. This will be handy when resolving relative paths. if project_name is not None : for section_name , sections in parser . sections . items (): for section in sections : section [ self . SECTION_PROJECT ] = project_name section [ self . SOONG_FILE ] = pathlib . Path ( file_path ) if project_path is not None : section [ self . SECTION_PROJECT_PATH ] = project_path self . sections [ section_name ] . append ( section ) project_variables . update ( parser . variables ) self . variables . update ( parser . variables ) parse_project ( self , project_directory , project_name , file_name = None ) Parse a project inside AOSP This methods expects the project to be an AOSP project (e.g. an entry in the manifest list of projects). Parameters: Name Type Description Default project_directory Union[str, pathlib.Path] Path towards the project required project_name str Name of the project required file_name Optional[str] Name of the soong files None Source code in bgraph/parsers/soong_parser.py def parse_project ( self , project_directory : Union [ str , pathlib . Path ], project_name : str , file_name : Optional [ str ] = None , ) -> None : \"\"\"Parse a project inside AOSP This methods expects the project to be an AOSP project (e.g. an entry in the manifest list of projects). :param project_directory: Path towards the project :param project_name: Name of the project :param file_name: Name of the soong files \"\"\" if file_name is None : file_name = self . DEFAULT_FILENAME project_directory = pathlib . Path ( project_directory ) project_variables : Dict [ str , Any ] = {} for soong_file in project_directory . rglob ( file_name ): self . parse_file ( file_path = soong_file , project_name = project_name , project_path = project_directory , project_variables = project_variables , ) # Sometimes in Android, a project may be have additional \"generic\" components # We try to include also Build Files files from those directories here to handle this case # This is a *dirty* hack and it should not be necessary when the project is from # the manifest. for soong_file in ( project_directory . parent / \"generic\" ) . rglob ( file_name ): self . parse_file ( file_path = soong_file )","title":"parsers"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser","text":"","title":"soong_parser"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.logger","text":"Logger.","title":"logger"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.Manifest","text":"A Manifest (for AOSP) is an XML file listing all the projects used for a version of AOSP. The repository listing all the manifests is found at : https://android.googlesource.com/platform/manifest/ This classes is a light wrapper around the XML File to query the parts of the manifest we are interested into. Parameters: Name Type Description Default manifest_content The content of a manifest required","title":"Manifest"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.Manifest.__init__","text":"Constructor method Source code in bgraph/parsers/soong_parser.py def __init__ ( self , manifest_content : str ) -> None : \"\"\"Constructor method\"\"\" try : self . xml : untangle . Element = untangle . parse ( manifest_content ) except xml . sax . SAXParseException as e : logger . exception ( e ) raise bgraph . exc . BGraphManifestException ( \"Unable to load the manifest\" ) if ( getattr ( self . xml , \"manifest\" , False ) is False or getattr ( self . xml . manifest , \"project\" , False ) is False ): raise bgraph . exc . BGraphManifestException ( \"Manifest misformed\" )","title":"__init__()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.Manifest.from_file","text":"Load a Manifest from a file Parameters: Name Type Description Default file_path Union[str, pathlib.Path] A PathLike object pointing to a file. required Returns: Type Description Manifest A Manifest class. Source code in bgraph/parsers/soong_parser.py @classmethod def from_file ( cls , file_path : Union [ str , pathlib . Path ]) -> \"Manifest\" : \"\"\"Load a Manifest from a file :param file_path: A PathLike object pointing to a file. :return: A `Manifest` class. \"\"\" file_path = pathlib . Path ( file_path ) if file_path . is_file (): return cls ( manifest_content = file_path . as_posix ()) raise bgraph . exc . BGraphManifestException ()","title":"from_file()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.Manifest.from_url","text":"Loads a manifest from an URL Warning: This methods parses arbitrary data from an URL. Use with caution <!> If the other_url parameter is set, this will be used as an absolute URL. Otherwise, it will fetch data from the googlesource servers. Parameters: Name Type Description Default manifest_name str Name of the manifest required other_url Optional[str] Use this url and not the one from Google None Returns: Type Description Manifest A Manifest class Source code in bgraph/parsers/soong_parser.py @classmethod def from_url ( cls , manifest_name : str , other_url : Optional [ str ] = None ) -> \"Manifest\" : \"\"\"Loads a manifest from an URL Warning: This methods parses arbitrary data from an URL. Use with caution <!> If the other_url parameter is set, this will be used as an absolute URL. Otherwise, it will fetch data from the googlesource servers. :param manifest_name: Name of the manifest :param other_url: Use this url and not the one from Google :return: A `Manifest` class \"\"\" try : import requests except ImportError : raise bgraph . exc . BGraphManifestException ( \"Must have requests installed for this action\" ) if other_url is None : url_content = f \"https://android.googlesource.com/platform/manifest/+/refs/heads/ { manifest_name } /default.xml?format=TEXT\" else : url_content = other_url try : response = requests . get ( url_content ) except requests . exceptions . RequestException as e : raise bgraph . exc . BGraphManifestException ( e ) try : xml_string : str = base64 . decodebytes ( response . content ) . decode ( response . encoding ) except TypeError as e : raise bgraph . exc . BGraphManifestException ( e ) return cls ( manifest_content = xml_string )","title":"from_url()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.Manifest.get_projects","text":"Returns the list of the projects for a manifest. Returns: Type Description Dict[str, str] A mapping between project name and project paths Source code in bgraph/parsers/soong_parser.py def get_projects ( self ) -> Dict [ str , str ]: \"\"\"Returns the list of the projects for a manifest. :return: A mapping between project name and project paths \"\"\" project_map : Dict [ str , str ] = {} for project in self . xml . manifest . project : project_name = project [ \"name\" ] project_path = project [ \"path\" ] if project_name is not None and project_path is not None : project_map [ project_name ] = project_path else : logger . warning ( \"Projet %s (@path: %s ) is None\" , project_name , project_path ) return project_map","title":"get_projects()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser","text":"Parser for soong files Set and parse a soong file. This is a best effort parser and some edge cases are not supported. Parameters: Name Type Description Default (Dict) variables Mapping of variables and their value inside the Blueprint file required","title":"SoongFileParser"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.__init__","text":"Constructor Source code in bgraph/parsers/soong_parser.py def __init__ ( self , file_path : Optional [ Union [ pathlib . Path , str ]] = None , variables : Dict [ str , Any ] = None , ): \"\"\"Constructor\"\"\" self . variables : Dict [ str , Any ] = {} if variables is not None : self . variables = variables self . identifiers : Dict [ str , Any ] = {} self . sections : Dict [ str , List [ Section ]] = collections . defaultdict ( list ) self . parser : pyparsing . ParserElement = self . _init_parser () if file_path : self . parser . parseFile ( pathlib . Path ( file_path ) . as_posix ()) if self . identifiers or not ( self . sections or self . variables ): raise bgraph . exc . BGraphParserException ( \"An error ocured during parsing\" )","title":"__init__()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_boolean","text":"Helper method to parse boolean Parameters: Name Type Description Default tokens List[Any] List of tokens required Returns: Type Description bool A boolean Exceptions: Type Description BGraphParserException When the boolean is not true or false Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_boolean ( tokens : List [ Any ]) -> bool : \"\"\"Helper method to parse boolean :param tokens: List of tokens :raises BGraphParserException: When the boolean is not true or false :return: A boolean \"\"\" token = tokens [ 0 ] if token == \"true\" : return True elif token == \"false\" : return False raise bgraph . exc . BGraphParserException ( \"Boolean exception\" )","title":"parse_boolean()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_dict_def","text":"Helper method to parse the dict definition Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_dict_def ( tokens ) -> Dict : \"\"\"Helper method to parse the dict definition\"\"\" result_dict = {} for token in tokens : result_dict . update ( token ) return result_dict","title":"parse_dict_def()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_dict_field","text":"Helper method to parse a map Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_dict_field ( tokens ) -> Dict : \"\"\"Helper method to parse a map\"\"\" key = tokens [ 0 ] val = tokens [ 1 ] if len ( tokens ) == 2 else tokens [ 1 :] return { key : val }","title":"parse_dict_field()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_integer","text":"Helper method to parse integers Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description int An integer Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_integer ( tokens : List [ str ]) -> int : \"\"\"Helper method to parse integers :param tokens: Tokens :return: An integer \"\"\" return int ( tokens [ 0 ])","title":"parse_integer()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_list_concat","text":"Helper for list concatenation Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description List[Any] A list of tokens Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_list_concat ( tokens : List [ str ]) -> List [ Any ]: \"\"\"Helper for list concatenation :param tokens: Tokens :return: A list of tokens \"\"\" final_list : List [ Any ] = [] for token in tokens : if type ( token ) is list : final_list . extend ( token ) elif type ( token ) is str : final_list . append ( token ) else : # Do not raise an exception as it may mess with pyparsing return [] return final_list","title":"parse_list_concat()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_section","text":"Parse a section Parameters: Name Type Description Default tokens List[str] Tokens required Exceptions: Type Description BGraphParserException If the parsing of the section fails Source code in bgraph/parsers/soong_parser.py def parse_section ( self , tokens : List [ str ]) -> None : \"\"\"Parse a section :param tokens: Tokens :raises BGraphParserException: If the parsing of the section fails \"\"\" section_name = None section_dict : Section = { SoongParser . SECTION_TYPE : tokens [ 0 ]} for token in tokens [ 1 :]: if token in self . identifiers : if token == \"name\" : section_name = self . identifiers [ token ] else : # TODO(dm) This will be resolved when we have a way to type hint a # dict with dynamic values section_dict [ token ] = self . identifiers [ token ] # type: ignore del self . identifiers [ token ] else : raise bgraph . exc . BGraphParserException ( \"Missing key {} in section {} \" . format ( token , section_name ) ) # Each section *must* have a name if section_name is None : # Except soong_namespace ... if section_dict [ SoongParser . SECTION_TYPE ] in ( \"soong_namespace\" ,): logger . debug ( \"Found a soong namespace but it is not supported yet.\" ) return raise bgraph . exc . BGraphParserException ( \"Section has no attribute name\" ) self . sections [ section_name ] . append ( section_dict )","title":"parse_section()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_section_field","text":"Parse a section field Example: name: \"libartbase_defaults\" Source code in bgraph/parsers/soong_parser.py def parse_section_field ( self , tokens : List [ str ]) -> str : \"\"\"Parse a section field Example: name: \"libartbase_defaults\" :return The name of the field \"\"\" if len ( tokens ) == 2 : self . identifiers [ tokens [ 0 ]] = tokens [ 1 ] elif len ( tokens ) > 2 : self . identifiers [ tokens [ 0 ]] = tokens [ 1 :] elif len ( tokens ) == 1 : # FIX: handle empty definitions like whole_static_libs: [] self . identifiers [ tokens [ 0 ]] = [] return tokens [ 0 ]","title":"parse_section_field()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_string_concat","text":"Helper method to concat string together Parameters: Name Type Description Default tokens List[str] Tokens required Returns: Type Description Optional[str] Optionnaly a string string Source code in bgraph/parsers/soong_parser.py @staticmethod def parse_string_concat ( tokens : List [ str ]) -> Optional [ str ]: \"\"\"Helper method to concat string together :param tokens: Tokens :return: Optionnaly a string string \"\"\" final_token = \"\" for token in tokens : if type ( token ) is str : final_token += token else : # Do not raise an exception as it may mess up with pyparsing return None return final_token","title":"parse_string_concat()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_variable_def","text":"Helper method to parse variable definition Parameters: Name Type Description Default _ N/A required __ N/A required tokens List[Any] Tokens to parse required append bool Should we appended the value to the existing one or not False Exceptions: Type Description BGraphParserException When the parsing fails Source code in bgraph/parsers/soong_parser.py def parse_variable_def ( self , _ , __ , tokens : List [ Any ], append : bool = False ) -> None : \"\"\"Helper method to parse variable definition :param _: N/A :param __: N/A :param tokens: Tokens to parse :param append: Should we appended the value to the existing one or not :raises BGraphParserException: When the parsing fails \"\"\" variable_name = tokens [ 0 ] new_value = tokens [ 1 ] if len ( tokens ) == 2 else tokens [ 1 :] if append is False : old_value = self . variables . get ( variable_name , None ) if old_value is not None and old_value != new_value : logger . debug ( \"Overwritting variable - in debug, check if legit.\" ) # raise bgraph.exc.BGraphParserException(\"Conflicting variables names\") self . variables [ variable_name ] = new_value else : actual_value = self . variables . get ( variable_name ) if actual_value is None : raise bgraph . exc . BGraphParserException ( \"Missing previous variable during append\" ) if type ( new_value ) != type ( actual_value ): new_value = [ new_value ] if type ( new_value ) is str else new_value actual_value = ( [ actual_value ] if type ( actual_value ) is str else actual_value ) self . variables [ variable_name ] = actual_value + new_value","title":"parse_variable_def()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongFileParser.parse_variable_ref","text":"Helper method to parse variable reference Parameters: Name Type Description Default tokens List[str] Tokens to parse required Returns: Type Description Any The variable value Source code in bgraph/parsers/soong_parser.py def parse_variable_ref ( self , tokens : List [ str ]) -> Any : \"\"\"Helper method to parse variable reference :param tokens: Tokens to parse :raises: BGraphParserException When the variables is used before being defined :return: The variable value \"\"\" var_name : str = tokens [ 0 ] if var_name not in self . variables : raise bgraph . exc . BGraphParserException ( \"Missing variable ref var_name\" ) return self . variables [ var_name ]","title":"parse_variable_ref()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser","text":"Soong Parser This is the wrapper around the parser for Soong file (e.g. Android.bp) Every section will be augmented with special keys (always prefixed with soong_parser).","title":"SoongParser"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.DEFAULT_FILENAME","text":"Default name for Soong file.","title":"DEFAULT_FILENAME"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.file_listing","text":"A map of every paths and files inside the project. This is used to resolve wildcards in filenames for Soong. Returns: Type Description Dict[pathlib.Path, List[str]] A maping between path and list of files inside an AOSP tree.","title":"file_listing"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.NATIVE_TYPES","text":"Type of section considered as \"natives\".","title":"NATIVE_TYPES"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.SECTION_PROJECT","text":"Name of the project for the current section.","title":"SECTION_PROJECT"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.SECTION_PROJECT_PATH","text":"Absolute path of the project in AOSP root tree.","title":"SECTION_PROJECT_PATH"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.SECTION_TYPE","text":"Type of the section (e.g. cc_library).","title":"SECTION_TYPE"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.SOONG_FILE","text":"Absolute path of the Soong file in AOSP root tree.","title":"SOONG_FILE"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.__init__","text":"Init method. Source code in bgraph/parsers/soong_parser.py def __init__ ( self ) -> None : \"\"\"Init method.\"\"\" self . sections : Dict [ str , List [ Section ]] = collections . defaultdict ( list ) self . variables : Dict [ str , Any ] = {} self . _files_listing : Dict [ pathlib . Path , List [ str ]] = {}","title":"__init__()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.get_section","text":"Get a section from the project. This is the main method of the class. It will also resolve the section defaults if any are found. Note that the name must be exact. Parameters: Name Type Description Default section_name str Name of the section required section_type Optional[str] Optional. Type of the section. If the type is defined, a single section will be returned of matching type. Otherwise all sections having the same name will be returned. None Returns: Type Description Union[List[bgraph.types.Section], bgraph.types.Section] A (list of) sections having the name asked. Source code in bgraph/parsers/soong_parser.py def get_section ( self , section_name : str , section_type : Optional [ str ] = None ) -> Union [ List [ Section ], Section ]: \"\"\"Get a section from the project. This is the main method of the class. It will also resolve the section defaults if any are found. Note that the name *must* be exact. :param section_name: Name of the section :param section_type: Optional. Type of the section. If the type is defined, a single section will be returned of matching type. Otherwise all sections having the same name will be returned. :return: A (list of) sections having the name asked. \"\"\" sections : List [ Section ] = self . _retrieve_section ( section_name ) if section_type is None : return sections for section in sections : if section [ self . SECTION_TYPE ] == section_type : return section raise bgraph . exc . BGraphMissingSectionException ()","title":"get_section()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.get_targets","text":"Compute the list of targets. A section is considered to be a target if the section_type is a binary type. This method is for now pretty simplist but could be improved. TODO: - add target parameter to filter targets - Filter also according to the value for the arch - add multi arch support - host/target difference Returns: Type Description List[str] A list of section having a \"binary\" target. Source code in bgraph/parsers/soong_parser.py def get_targets ( self ) -> List [ str ]: \"\"\"Compute the list of targets. A section is considered to be a target if the section_type is a binary type. This method is for now pretty simplist but could be improved. TODO: - add target parameter to filter targets - Filter also according to the value for the arch - add multi arch support - host/target difference :return: A list of section having a \"binary\" target. \"\"\" target_list : List [ str ] = [] for section_name in self . list_section ( with_defaults = False ): section_map : List [ Section ] = self . get_section ( section_name ) for section in section_map : section_type = section . get ( self . SECTION_TYPE ) if section_type in [ \"cc_library\" , \"cc_library_shared\" , \"cc_library_static\" , ]: # The target is actually the name of the section. Manual says it can # be overriden but I did not find any evidence of that. # TODO(dm) : see if the name if overriden & check if the lib is not # disabled for target ? (how?) target_list . append ( section_name ) elif section_type in [ \"cc_binary\" , ]: target_list . append ( section_name ) return target_list","title":"get_targets()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.list_section","text":"List sections found in AOSP. Parameters: Name Type Description Default with_defaults bool Also include defaults sections in the results False Returns: Type Description List[str] A list of sections Source code in bgraph/parsers/soong_parser.py def list_section ( self , with_defaults : bool = False ) -> List [ str ]: \"\"\"List sections found in AOSP. :param with_defaults: Also include defaults sections in the results :return: A list of sections \"\"\" section_list : List [ str ] = [] for section_name , targets in self . sections . items (): if with_defaults or any ( \"default\" not in target . get ( self . SECTION_TYPE , \"\" ) for target in targets ): section_list . append ( section_name ) return section_list","title":"list_section()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.parse_aosp","text":"Parses an AOSP tree. This methods only needs the soong file to be present so a partial checkout is enough to create the listing. The project map is needed because it needs to know the root tree of a project. Parameters: Name Type Description Default aosp_directory Union[str, pathlib.Path] Root tree of AOSP required file_name Optional[str] Optional Name of file None project_map Dict A map of project name / project path None Source code in bgraph/parsers/soong_parser.py def parse_aosp ( self , aosp_directory : Union [ str , pathlib . Path ], file_name : Optional [ str ] = None , project_map : Dict = None , ) -> None : \"\"\"Parses an AOSP tree. This methods only needs the soong file to be present so a partial checkout is enough to create the listing. The project map is needed because it needs to know the root tree of a project. :param aosp_directory: Root tree of AOSP :param file_name: Optional Name of file :param project_map: A map of project name / project path \"\"\" if file_name is None : file_name = self . DEFAULT_FILENAME if project_map is None : raise bgraph . exc . BGraphParserException ( \"Missing project map.\" ) aosp_directory = pathlib . Path ( aosp_directory ) for project_name , relative_path in project_map . items (): project_path = aosp_directory / relative_path self . parse_project ( project_directory = project_path , file_name = file_name , project_name = project_name , )","title":"parse_aosp()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.parse_file","text":"Parse a file (e.g. an Android.bp) and update the current class. Note: This will silently fails if the file is misformed. Parameters: Name Type Description Default file_path Union[str, pathlib.Path] Path towards the file required project_name str Optional. Name of the current project None project_path Optional[pathlib.Path] Optional. Path to the root of the project None project_variables Dict[str, Any] Variables already set for the project None Source code in bgraph/parsers/soong_parser.py def parse_file ( self , file_path : Union [ str , pathlib . Path ], project_name : str = None , project_path : Optional [ pathlib . Path ] = None , project_variables : Dict [ str , Any ] = None , ) -> None : \"\"\"Parse a file (e.g. an Android.bp) and update the current class. Note: This will silently fails if the file is misformed. :param file_path: Path towards the file :param project_name: Optional. Name of the current project :param project_path: Optional. Path to the root of the project :param project_variables: Variables already set for the project \"\"\" if project_variables is None : project_variables = {} try : parser = SoongFileParser ( file_path , project_variables ) except bgraph . exc . BGraphParserException : # The parser is a best effort one. If it fails, do not try to hard but # report the error if in DEBUG mode. logger . debug ( \"Failed to parse %s \" , file_path ) return # If we are doing a parsing of a project, we want to store more information on # the sections, namely where was the initial file located and the root source of # the project. This will be handy when resolving relative paths. if project_name is not None : for section_name , sections in parser . sections . items (): for section in sections : section [ self . SECTION_PROJECT ] = project_name section [ self . SOONG_FILE ] = pathlib . Path ( file_path ) if project_path is not None : section [ self . SECTION_PROJECT_PATH ] = project_path self . sections [ section_name ] . append ( section ) project_variables . update ( parser . variables ) self . variables . update ( parser . variables )","title":"parse_file()"},{"location":"reference/parsers/parsers/#bgraph.parsers.soong_parser.SoongParser.parse_project","text":"Parse a project inside AOSP This methods expects the project to be an AOSP project (e.g. an entry in the manifest list of projects). Parameters: Name Type Description Default project_directory Union[str, pathlib.Path] Path towards the project required project_name str Name of the project required file_name Optional[str] Name of the soong files None Source code in bgraph/parsers/soong_parser.py def parse_project ( self , project_directory : Union [ str , pathlib . Path ], project_name : str , file_name : Optional [ str ] = None , ) -> None : \"\"\"Parse a project inside AOSP This methods expects the project to be an AOSP project (e.g. an entry in the manifest list of projects). :param project_directory: Path towards the project :param project_name: Name of the project :param file_name: Name of the soong files \"\"\" if file_name is None : file_name = self . DEFAULT_FILENAME project_directory = pathlib . Path ( project_directory ) project_variables : Dict [ str , Any ] = {} for soong_file in project_directory . rglob ( file_name ): self . parse_file ( file_path = soong_file , project_name = project_name , project_path = project_directory , project_variables = project_variables , ) # Sometimes in Android, a project may be have additional \"generic\" components # We try to include also Build Files files from those directories here to handle this case # This is a *dirty* hack and it should not be necessary when the project is from # the manifest. for soong_file in ( project_directory . parent / \"generic\" ) . rglob ( file_name ): self . parse_file ( file_path = soong_file )","title":"parse_project()"},{"location":"reference/viewer/viewer/","text":"formatter format_dot ( graph , results , query , query_value ) Output result as DOT. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_dot ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Output result as DOT. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" if query == QueryType . SOURCE : subgraph = networkx . generators . ego_graph ( graph , query_value , center = True , radius = None ) elif query == QueryType . TARGET : subgraph = networkx . generators . ego_graph ( graph . reverse (), query_value , center = True , radius = None ) elif query == QueryType . DEPENDENCY : subgraph = graph . subgraph ( results ) else : raise NotImplementedError ( \"Not implemented yet\" ) pydot_graph = networkx . nx_pydot . to_pydot ( subgraph ) # Clean data for node in pydot_graph . get_nodes (): try : del node . obj_dict [ \"attributes\" ][ \"data\" ] except KeyError : pass try : target = pydot_graph . get_node ( pydot . quote_if_necessary ( query_value ))[ 0 ] except IndexError : raise bgraph . exc . BGraphNodeNotFound ( \"Unable to find node\" ) target . set_shape ( \"box\" ) target . set_color ( \"red\" ) typer . echo ( pydot_graph ) format_json ( graph , results , query , query_value ) Output the result as JSON Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_json ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Output the result as JSON :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" query_dict = { QueryType . TARGET : [ \"target\" , \"Search sources for a target\" ], QueryType . SOURCE : [ \"sources\" , \"Search target for a source\" ], QueryType . DEPENDENCY : [ \"dependency\" , \"Search dependencies for a target\" ], } result_dict : ResultDict = {} if query == QueryType . TARGET : result_dict [ \"sources\" ] = results elif query == QueryType . DEPENDENCY or query == QueryType . SOURCE : result_dict [ \"target\" ] = [] for result in results : result_dict [ \"target\" ] . append ( ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ])) ) typer . echo ( json . dumps ( { \"_meta\" : { \"query\" : query_dict [ query ][ 0 ], \"desc\" : query_dict [ query ][ 1 ], \"query_value\" : query_value , }, \"result\" : result_dict , }, indent = True , ) ) format_result ( graph , results , query , query_value , out_choice ) Format the result of the viewer. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required out_choice OutChoice Out format required Source code in bgraph/viewer/formatter.py def format_result ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str , out_choice : OutChoice , ) -> None : \"\"\"Format the result of the viewer. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value :param out_choice: Out format \"\"\" format_methods = { out_choice . TXT : format_text , out_choice . JSON : format_json , out_choice . DOT : format_dot , } return format_methods [ out_choice ]( graph , results , query , query_value ) format_text ( graph , results , query , query_value ) Format the results for text consumption (default value). Use rich to do some pretty formatting. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_text ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Format the results for text consumption (default value). Use rich to do some pretty formatting. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" table = rich . table . Table ( box = rich . box . MINIMAL_DOUBLE_HEAD ) if query == QueryType . TARGET : table . title = f \"Sources for the target { query_value } \" table . add_column ( \"Filename\" , justify = \"left\" ) table . add_column ( \"File type\" , justify = \"right\" ) for result in results : table . add_row ( result , Path ( result ) . suffix ) elif query == QueryType . DEPENDENCY : table . title = f \"Dependencies for the target { query_value } \" table . add_column ( \"Dependency\" ) table . add_column ( \"Type\" ) table . add_column ( \"Ascending\" ) for result in sorted ( results ): ascending = ( \":heavy_check_mark:\" if networkx . has_path ( graph , result , query_value ) else \":heavy_multiplication_x:\" ) table . add_row ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ]), ascending ) elif query == QueryType . SOURCE : table . title = f \"Dependencies for source file { Path ( query_value ) . name } \" table . add_column ( \"Target\" ) table . add_column ( \"Type\" ) table . add_column ( \"Distance\" ) # Generate the graph to compute the distance # Since the graph is much simpler than the original one, it is easier to compute # the distance inside this one. generated_graph : BGraph = networkx . generators . ego_graph ( graph , query_value , center = True , radius = None ) row_results : List [ Tuple [ str , NodeType , int ]] = [ ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ]), networkx . algorithms . shortest_path_length ( generated_graph , query_value , result ), ) for result in results ] for result , node_type , distance in sorted ( row_results , key = lambda x : x [ 2 ]): table . add_row ( result , node_type , f \" { distance } \" ) console = rich . console . Console () console . print ( table ) loader load_graph ( graph_path ) Load a B-Graph and return the DiGraph associated. Parameters: Name Type Description Default graph Path to the graph file (stored with pickle) required Returns: Type Description DiGraph A DiGraph Source code in bgraph/viewer/loader.py def load_graph ( graph_path : Union [ str , pathlib . Path ]) -> BGraph : \"\"\"Load a B-Graph and return the DiGraph associated. :param graph: Path to the graph file (stored with pickle) :return: A DiGraph \"\"\" try : graph : BGraph = pickle . load ( open ( graph_path , \"rb\" )) except ( pickle . PickleError , FileNotFoundError ): raise bgraph . exc . BGraphLoadingException ( \"Unable to load the graph.\" ) return graph viewer DEFAULT_TYPES : List [ str ] Default soong types to consider logger : Logger Logger. find_dependency ( graph , origin ) Resolve dependencies in a graph. Given an origin (which is not a source file), find all dependents targets Parameters: Name Type Description Default graph DiGraph Graph to search required origin str Origin of the query required Returns: Type Description List[str] A list of dependent target Source code in bgraph/viewer/viewer.py def find_dependency ( graph : BGraph , origin : str ) -> List [ str ]: \"\"\"Resolve dependencies in a graph. Given an origin (which is *not* a source file), find all dependents targets :param graph: Graph to search :param origin: Origin of the query :return: A list of dependent target \"\"\" if origin not in graph : logger . error ( \"Origin not found %s \" , origin ) return [] # Get dependencies in the graph subgraph = nx . generators . ego_graph ( graph , origin , radius = None , center = True ) other_subgraph = nx . generators . ego_graph ( graph . reverse (), origin , center = True , radius = None ) return list ( set ( subgraph ) . union ( set ( other_subgraph ))) find_sources ( graph , target ) Find the sources of target. Recursively in the graph, search for all sources files of a target (or a target dependencies). TODO(dm): For conditionals, there may also exists precomputed binaries as the target. Find a way to deal with those Parameters: Name Type Description Default graph DiGraph Graph yo search required target str Origin of the query (final target) required Returns: Type Description List[str] A list of source files Source code in bgraph/viewer/viewer.py def find_sources ( graph : BGraph , target : str ) -> List [ str ]: \"\"\"Find the sources of target. Recursively in the graph, search for all sources files of a target (or a target dependencies). TODO(dm): For conditionals, there may also exists precomputed binaries as the target. Find a way to deal with those :param graph: Graph yo search :param target: Origin of the query (final target) :return: A list of source files \"\"\" if target not in graph : return [] subgraph = nx . generators . ego_graph ( graph . reverse (), target , radius = None , center = False ) dependencies = [ node for node in subgraph if next ( subgraph . successors ( node ), None ) is None ] # Filtering step: since we don't understand conditionals (yet), filter out bogus # dependencies # TODO(dm) return dependencies find_target ( graph , source , return_types = [ 'cc_library_shared' , 'cc_library' , 'cc_binary' , 'cc_library_static' , 'android_app' ], radius = None ) Given a source file, find all dependent targets. This is a bit trickier as the source file may be given with an incomplete path. However, we don't want to give absurds results, so if more than 1 file matches, an error is raised. TODO(dm): - Intersect for multiple sources files - Better handling of return types Parameters: Name Type Description Default graph DiGraph The graph to search required source str Source file name required return_types List[str] Optional. List of types to consider as valid types ['cc_library_shared', 'cc_library', 'cc_binary', 'cc_library_static', 'android_app'] radius Optional[int] Optional. How far should the graph go. Default is None : consider all the dependencies. A positive integer will reduce to node at at most radius distance. None Returns: Type Description Tuple[str, List[str]] A tuple with the exact match and the list of results Source code in bgraph/viewer/viewer.py def find_target ( graph : BGraph , source : str , return_types : List [ str ] = DEFAULT_TYPES , radius : Optional [ int ] = None , ) -> Tuple [ str , List [ str ]]: \"\"\"Given a source file, find all dependent targets. This is a bit trickier as the source file may be given with an incomplete path. However, we don't want to give absurds results, so if more than 1 file matches, an error is raised. TODO(dm): - Intersect for multiple sources files - Better handling of return types :param graph: The graph to search :param source: Source file name :param return_types: Optional. List of types to consider as valid types :param radius: Optional. How far should the graph go. Default is None : consider all the dependencies. A positive integer will reduce to node at at most `radius` distance. :return: A tuple with the exact match and the list of results \"\"\" graph_srcs : List [ str ] = get_graph_srcs ( graph ) try : matched_node = match_node ( graph_srcs , source ) except ( bgraph . exc . BGraphNodeNotFound , bgraph . exc . BGraphTooManyNodes ) as e : logger . info ( \"Failed to find node with error %s \" , e ) return \"\" , [] subgraph = nx . generators . ego_graph ( graph , matched_node , center = False , radius = radius ) results = [ node for node in subgraph if any ( node_type in return_types for node_type in get_node_type ( graph . nodes [ node ], all_types = True ) ) ] return matched_node , results get_graph_srcs ( graph ) Filter the graph to return only source nodes. This method is used to improve the efficiency of the match_node method. Parameters: Name Type Description Default graph DiGraph The BGraph to filter required Returns: Type Description List[str] A list of graph nodes representing source file. Source code in bgraph/viewer/viewer.py @functools . lru_cache ( maxsize = 8 ) def get_graph_srcs ( graph : BGraph ) -> List [ str ]: \"\"\"Filter the graph to return only source nodes. This method is used to improve the efficiency of the `match_node` method. :param graph: The BGraph to filter :return: A list of graph nodes representing source file. \"\"\" return [ node for node in graph if get_node_type ( node ) == \"source\" ] get_node_type ( node_d , all_types = False ) Get the node type Sources nodes (e.g leaves) have no data associated so we use this fact. Source code in bgraph/viewer/viewer.py def get_node_type ( node_d : Dict , all_types : bool = False ) -> Union [ NodeType , List [ NodeType ]]: \"\"\"Get the node type Sources nodes (e.g leaves) have no data associated so we use this fact. :param node_d A node :param all_types Optional. Return all the types possible for the node :return Type(s) of the node \"\"\" try : node_types = [ node [ bgraph . parsers . SoongParser . SECTION_TYPE ] for node in node_d [ \"data\" ] ] except ( TypeError , KeyError ): return \"source\" if all_types is False else [ \"source\" ] if all_types : return node_types else : # Return only the first node type return node_types . pop () match_node ( graph_srcs , node_name ) Search for a node matching the name given as an argument. Parameters: Name Type Description Default graph_srcs List[str] A list of source node in the graph required node_name str A node name required Returns: Type Description str A node Source code in bgraph/viewer/viewer.py def match_node ( graph_srcs : List [ str ], node_name : str ) -> str : \"\"\"Search for a node matching the name given as an argument. :param graph_srcs: A list of source node in the graph :param node_name: A node name :return: A node \"\"\" potential_results = [ node for node in graph_srcs if node_name in node ] if not potential_results : raise bgraph . exc . BGraphNodeNotFound ( \"Found 0 results\" ) elif len ( potential_results ) > 1 : # TODO(dm) : We have a problem here because we have too many nodes that may # match but it is not supposed to happen. raise bgraph . exc . BGraphTooManyNodes ( \"Found many results - refine the search\" ) return potential_results . pop ()","title":"viewer"},{"location":"reference/viewer/viewer/#bgraph.viewer.formatter","text":"","title":"formatter"},{"location":"reference/viewer/viewer/#bgraph.viewer.formatter.format_dot","text":"Output result as DOT. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_dot ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Output result as DOT. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" if query == QueryType . SOURCE : subgraph = networkx . generators . ego_graph ( graph , query_value , center = True , radius = None ) elif query == QueryType . TARGET : subgraph = networkx . generators . ego_graph ( graph . reverse (), query_value , center = True , radius = None ) elif query == QueryType . DEPENDENCY : subgraph = graph . subgraph ( results ) else : raise NotImplementedError ( \"Not implemented yet\" ) pydot_graph = networkx . nx_pydot . to_pydot ( subgraph ) # Clean data for node in pydot_graph . get_nodes (): try : del node . obj_dict [ \"attributes\" ][ \"data\" ] except KeyError : pass try : target = pydot_graph . get_node ( pydot . quote_if_necessary ( query_value ))[ 0 ] except IndexError : raise bgraph . exc . BGraphNodeNotFound ( \"Unable to find node\" ) target . set_shape ( \"box\" ) target . set_color ( \"red\" ) typer . echo ( pydot_graph )","title":"format_dot()"},{"location":"reference/viewer/viewer/#bgraph.viewer.formatter.format_json","text":"Output the result as JSON Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_json ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Output the result as JSON :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" query_dict = { QueryType . TARGET : [ \"target\" , \"Search sources for a target\" ], QueryType . SOURCE : [ \"sources\" , \"Search target for a source\" ], QueryType . DEPENDENCY : [ \"dependency\" , \"Search dependencies for a target\" ], } result_dict : ResultDict = {} if query == QueryType . TARGET : result_dict [ \"sources\" ] = results elif query == QueryType . DEPENDENCY or query == QueryType . SOURCE : result_dict [ \"target\" ] = [] for result in results : result_dict [ \"target\" ] . append ( ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ])) ) typer . echo ( json . dumps ( { \"_meta\" : { \"query\" : query_dict [ query ][ 0 ], \"desc\" : query_dict [ query ][ 1 ], \"query_value\" : query_value , }, \"result\" : result_dict , }, indent = True , ) )","title":"format_json()"},{"location":"reference/viewer/viewer/#bgraph.viewer.formatter.format_result","text":"Format the result of the viewer. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required out_choice OutChoice Out format required Source code in bgraph/viewer/formatter.py def format_result ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str , out_choice : OutChoice , ) -> None : \"\"\"Format the result of the viewer. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value :param out_choice: Out format \"\"\" format_methods = { out_choice . TXT : format_text , out_choice . JSON : format_json , out_choice . DOT : format_dot , } return format_methods [ out_choice ]( graph , results , query , query_value )","title":"format_result()"},{"location":"reference/viewer/viewer/#bgraph.viewer.formatter.format_text","text":"Format the results for text consumption (default value). Use rich to do some pretty formatting. Parameters: Name Type Description Default graph DiGraph BGraph required results List[str] Results for the query required query QueryType Type of the query required query_value str Query value required Source code in bgraph/viewer/formatter.py def format_text ( graph : BGraph , results : List [ str ], query : QueryType , query_value : str ) -> None : \"\"\"Format the results for text consumption (default value). Use rich to do some pretty formatting. :param graph: BGraph :param results: Results for the query :param query: Type of the query :param query_value: Query value \"\"\" table = rich . table . Table ( box = rich . box . MINIMAL_DOUBLE_HEAD ) if query == QueryType . TARGET : table . title = f \"Sources for the target { query_value } \" table . add_column ( \"Filename\" , justify = \"left\" ) table . add_column ( \"File type\" , justify = \"right\" ) for result in results : table . add_row ( result , Path ( result ) . suffix ) elif query == QueryType . DEPENDENCY : table . title = f \"Dependencies for the target { query_value } \" table . add_column ( \"Dependency\" ) table . add_column ( \"Type\" ) table . add_column ( \"Ascending\" ) for result in sorted ( results ): ascending = ( \":heavy_check_mark:\" if networkx . has_path ( graph , result , query_value ) else \":heavy_multiplication_x:\" ) table . add_row ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ]), ascending ) elif query == QueryType . SOURCE : table . title = f \"Dependencies for source file { Path ( query_value ) . name } \" table . add_column ( \"Target\" ) table . add_column ( \"Type\" ) table . add_column ( \"Distance\" ) # Generate the graph to compute the distance # Since the graph is much simpler than the original one, it is easier to compute # the distance inside this one. generated_graph : BGraph = networkx . generators . ego_graph ( graph , query_value , center = True , radius = None ) row_results : List [ Tuple [ str , NodeType , int ]] = [ ( result , bgraph . viewer . get_node_type ( graph . nodes [ result ]), networkx . algorithms . shortest_path_length ( generated_graph , query_value , result ), ) for result in results ] for result , node_type , distance in sorted ( row_results , key = lambda x : x [ 2 ]): table . add_row ( result , node_type , f \" { distance } \" ) console = rich . console . Console () console . print ( table )","title":"format_text()"},{"location":"reference/viewer/viewer/#bgraph.viewer.loader","text":"","title":"loader"},{"location":"reference/viewer/viewer/#bgraph.viewer.loader.load_graph","text":"Load a B-Graph and return the DiGraph associated. Parameters: Name Type Description Default graph Path to the graph file (stored with pickle) required Returns: Type Description DiGraph A DiGraph Source code in bgraph/viewer/loader.py def load_graph ( graph_path : Union [ str , pathlib . Path ]) -> BGraph : \"\"\"Load a B-Graph and return the DiGraph associated. :param graph: Path to the graph file (stored with pickle) :return: A DiGraph \"\"\" try : graph : BGraph = pickle . load ( open ( graph_path , \"rb\" )) except ( pickle . PickleError , FileNotFoundError ): raise bgraph . exc . BGraphLoadingException ( \"Unable to load the graph.\" ) return graph","title":"load_graph()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer","text":"","title":"viewer"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.DEFAULT_TYPES","text":"Default soong types to consider","title":"DEFAULT_TYPES"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.logger","text":"Logger.","title":"logger"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.find_dependency","text":"Resolve dependencies in a graph. Given an origin (which is not a source file), find all dependents targets Parameters: Name Type Description Default graph DiGraph Graph to search required origin str Origin of the query required Returns: Type Description List[str] A list of dependent target Source code in bgraph/viewer/viewer.py def find_dependency ( graph : BGraph , origin : str ) -> List [ str ]: \"\"\"Resolve dependencies in a graph. Given an origin (which is *not* a source file), find all dependents targets :param graph: Graph to search :param origin: Origin of the query :return: A list of dependent target \"\"\" if origin not in graph : logger . error ( \"Origin not found %s \" , origin ) return [] # Get dependencies in the graph subgraph = nx . generators . ego_graph ( graph , origin , radius = None , center = True ) other_subgraph = nx . generators . ego_graph ( graph . reverse (), origin , center = True , radius = None ) return list ( set ( subgraph ) . union ( set ( other_subgraph )))","title":"find_dependency()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.find_sources","text":"Find the sources of target. Recursively in the graph, search for all sources files of a target (or a target dependencies). TODO(dm): For conditionals, there may also exists precomputed binaries as the target. Find a way to deal with those Parameters: Name Type Description Default graph DiGraph Graph yo search required target str Origin of the query (final target) required Returns: Type Description List[str] A list of source files Source code in bgraph/viewer/viewer.py def find_sources ( graph : BGraph , target : str ) -> List [ str ]: \"\"\"Find the sources of target. Recursively in the graph, search for all sources files of a target (or a target dependencies). TODO(dm): For conditionals, there may also exists precomputed binaries as the target. Find a way to deal with those :param graph: Graph yo search :param target: Origin of the query (final target) :return: A list of source files \"\"\" if target not in graph : return [] subgraph = nx . generators . ego_graph ( graph . reverse (), target , radius = None , center = False ) dependencies = [ node for node in subgraph if next ( subgraph . successors ( node ), None ) is None ] # Filtering step: since we don't understand conditionals (yet), filter out bogus # dependencies # TODO(dm) return dependencies","title":"find_sources()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.find_target","text":"Given a source file, find all dependent targets. This is a bit trickier as the source file may be given with an incomplete path. However, we don't want to give absurds results, so if more than 1 file matches, an error is raised. TODO(dm): - Intersect for multiple sources files - Better handling of return types Parameters: Name Type Description Default graph DiGraph The graph to search required source str Source file name required return_types List[str] Optional. List of types to consider as valid types ['cc_library_shared', 'cc_library', 'cc_binary', 'cc_library_static', 'android_app'] radius Optional[int] Optional. How far should the graph go. Default is None : consider all the dependencies. A positive integer will reduce to node at at most radius distance. None Returns: Type Description Tuple[str, List[str]] A tuple with the exact match and the list of results Source code in bgraph/viewer/viewer.py def find_target ( graph : BGraph , source : str , return_types : List [ str ] = DEFAULT_TYPES , radius : Optional [ int ] = None , ) -> Tuple [ str , List [ str ]]: \"\"\"Given a source file, find all dependent targets. This is a bit trickier as the source file may be given with an incomplete path. However, we don't want to give absurds results, so if more than 1 file matches, an error is raised. TODO(dm): - Intersect for multiple sources files - Better handling of return types :param graph: The graph to search :param source: Source file name :param return_types: Optional. List of types to consider as valid types :param radius: Optional. How far should the graph go. Default is None : consider all the dependencies. A positive integer will reduce to node at at most `radius` distance. :return: A tuple with the exact match and the list of results \"\"\" graph_srcs : List [ str ] = get_graph_srcs ( graph ) try : matched_node = match_node ( graph_srcs , source ) except ( bgraph . exc . BGraphNodeNotFound , bgraph . exc . BGraphTooManyNodes ) as e : logger . info ( \"Failed to find node with error %s \" , e ) return \"\" , [] subgraph = nx . generators . ego_graph ( graph , matched_node , center = False , radius = radius ) results = [ node for node in subgraph if any ( node_type in return_types for node_type in get_node_type ( graph . nodes [ node ], all_types = True ) ) ] return matched_node , results","title":"find_target()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.get_graph_srcs","text":"Filter the graph to return only source nodes. This method is used to improve the efficiency of the match_node method. Parameters: Name Type Description Default graph DiGraph The BGraph to filter required Returns: Type Description List[str] A list of graph nodes representing source file. Source code in bgraph/viewer/viewer.py @functools . lru_cache ( maxsize = 8 ) def get_graph_srcs ( graph : BGraph ) -> List [ str ]: \"\"\"Filter the graph to return only source nodes. This method is used to improve the efficiency of the `match_node` method. :param graph: The BGraph to filter :return: A list of graph nodes representing source file. \"\"\" return [ node for node in graph if get_node_type ( node ) == \"source\" ]","title":"get_graph_srcs()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.get_node_type","text":"Get the node type Sources nodes (e.g leaves) have no data associated so we use this fact. Source code in bgraph/viewer/viewer.py def get_node_type ( node_d : Dict , all_types : bool = False ) -> Union [ NodeType , List [ NodeType ]]: \"\"\"Get the node type Sources nodes (e.g leaves) have no data associated so we use this fact. :param node_d A node :param all_types Optional. Return all the types possible for the node :return Type(s) of the node \"\"\" try : node_types = [ node [ bgraph . parsers . SoongParser . SECTION_TYPE ] for node in node_d [ \"data\" ] ] except ( TypeError , KeyError ): return \"source\" if all_types is False else [ \"source\" ] if all_types : return node_types else : # Return only the first node type return node_types . pop ()","title":"get_node_type()"},{"location":"reference/viewer/viewer/#bgraph.viewer.viewer.match_node","text":"Search for a node matching the name given as an argument. Parameters: Name Type Description Default graph_srcs List[str] A list of source node in the graph required node_name str A node name required Returns: Type Description str A node Source code in bgraph/viewer/viewer.py def match_node ( graph_srcs : List [ str ], node_name : str ) -> str : \"\"\"Search for a node matching the name given as an argument. :param graph_srcs: A list of source node in the graph :param node_name: A node name :return: A node \"\"\" potential_results = [ node for node in graph_srcs if node_name in node ] if not potential_results : raise bgraph . exc . BGraphNodeNotFound ( \"Found 0 results\" ) elif len ( potential_results ) > 1 : # TODO(dm) : We have a problem here because we have too many nodes that may # match but it is not supposed to happen. raise bgraph . exc . BGraphTooManyNodes ( \"Found many results - refine the search\" ) return potential_results . pop ()","title":"match_node()"}]}